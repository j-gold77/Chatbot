Analysis of AlgorithmsBreadth-First Search (BFS)Dr. Aiman HannaDepartment of Computer Science & Software Engineering Concordia University, Montreal, CanadaThese slides have been extracted, modified and updated from original slides of :Data Structures and Algorithms in Java, 5th edition. John Wiley& Sons, 2010. ISBN 978-0-470-38326-1.Data Structures and the Java Collections Framework by William J. Collins, 3rdedition, ISBN 978-0-470-48267-4. Both books are published by Wiley.Copyright © 2010-2011 WileyCopyright © 2010 Michael  T. Goodrich, Roberto TamassiaCopyright © 2011 William J. CollinsCopyright © 2011-2021 Aiman Hanna All rights reserved Coverage Graph Traversal  Breath-First Search (BFS)2CBAEDL0L1FL2Breadth-First SearchBreadth-First Search 3Breadth-First Search (BFS) BFS is less adventurous than DFS, in the sense that it does not travel far, at any point of time, from where it starts  The idea is similar to travelling between cities. First go and visit all the cities that are closest to you. If this goes fine, think about travelling to cities that are further. If this goes fine, go and travel to the ones that are even further! By the time you are adventurous, there are no more cities to visit! Consequently, BFS subdivides the vertices into levelsand goes “as if” in rounds to visit the vertices (Still, equipment needed are a rolled robe, and can of paint spray). Breadth-First Search 4BFS BFS performs as follows:   Start at some vertex s, which is considered as level 0. This vertex is also referred to as the “anchor” (All following explorations will be based on a distance from that anchor) Unroll the robe with length equivalent to the length of one edge. Go to all the vertices that you can reach with that length. These vertices belong to level 1. Paint the vertices that you visit (to mark them as VISTED) Once all the vertices in level 1 are visited, unroll the robe further to twice the length of an edge. Similarly go and visit all the vertices that you can reach with that length.  These vertices form level 2. If the exploration through an edge leads to an already visited vertex, mark that edge as “cross”; otherwise mark it as “discovery” Repeat the above operation, visiting further levels, until no more vertices are there to visit Breadth-First Search 5BFS Example1CBAEDdiscovery edgecross edgeA visited vertexA unexplored vertexunexplored edgeL0L1FCBAEDL0L1FCBAEDL0L1FBreadth-First Search 6BFS Example1 (cont.)CBAEDL0L1FCBAEDL0L1FL2CBAEDL0L1FL2CBAEDL0L1FL2Breadth-First Search 7BFS Example1 (cont.)CBAEDL0L1FL2CBAEDL0L1FL2CBAEDL0L1FL2Breadth-First Search 8BFS Algorithm The algorithm uses a mechanism for setting and getting “labels” of vertices and edgesAlgorithm BFS(G, s)L0 ← new empty sequenceL0.addLast(s)setLabel(s, VISITED)i ← 0while ¬Li.isEmpty()Li +1 ← new empty sequencefor all v ∈ Li.elements() for all e ∈ G.incidentEdges(v)if getLabel(e) = UNEXPLOREDw ← opposite(v,e)if  getLabel(w) = UNEXPLOREDsetLabel(e, DISCOVERY)setLabel(w, VISITED)Li +1.addLast(w)elsesetLabel(e, CROSS)i ← i +1Algorithm BFS(G)Input graph GOutput labeling of the edges and partition of the vertices  of G for all u ∈ G.vertices()setLabel(u, UNEXPLORED)for all e ∈ G.edges()setLabel(e, UNEXPLORED)for all v ∈ G.vertices()if getLabel(v) = UNEXPLOREDBFS(G, v)Breadth-First Search9BFS Example2cross edgediscovery edgeA visited vertex (Thicker one indicates the anchor)A unexplored vertexunexplored edgeBA DCFE HGJI LKNM POBA DCFE HGJI LKNM PO0 1BA DCFE HGJI LKNM PO0 1 210BFS Example2 (cont.)cross edgediscovery edgeA visited vertex (Thicker one indicates the anchor)A unexplored vertexunexplored edgeBA DCFE HGJI LKNM PO0 1 2 3BA DCFE HGJI LKNM PO0 1 2 34BA DCFE HGJI LKNM PO0 1 2 34511BFS Example2 (cont.)cross edgediscovery edgeA visited vertex (Thicker one indicates the anchor)A unexplored vertexunexplored edgeBA DCFE HGJI LKNM PO0 1 2 345BA DCFE HGJI LKNM PO0 1 2 345Nothing is added to Level 6. So, terminate as Level 6 is empty Breadth-First Search 12BFS Analysis  Notice that:  Discovery edges form a spanning tree, which is referred to as BFS tree Edges to already visited vertices are called “cross” edges and not “back” edges since these edges do not connect vertices to their ancestors. In fact all of these (non-tree) edges neither connect a vertex to its ancestor, nor to its descendant on the BFS treeWe never go back to the anchor; instead we always start from the nodes of leveli to go to leveli+1Breadth-First Search 13BFS Analysis  Using a BFS traversal over a graph G, it is possible to solve the following problems: (note: that is actually done using algorithms and subroutines that are slightly different than the above simplified shown algorithm) Visit all the vertices and edges of G Determine whether G is connected Compute spanning tree of G is G is connected Compute the spanning forest of G (all spanning trees) if G is a non-connected graph Compute the connected components of G Find a cycle of G, or report that G has no cycles Given a start vertex s of G, compute for every vertex v of G, a path with the minimum number of edges between sand v, or report that no such path exists However, what is the complexity of BFS? Breadth-First Search14BFS Analysis  BFS on a graph with n vertices and m edges takes O(n + m ) time since: Setting/getting a vertex/edge label takes O(1) time Each vertex is labeled twice  once as UNEXPLORED once as VISITED Each edge is labeled twice once as UNEXPLORED once as DISCOVERY or CROSS Each vertex is inserted once into a sequence Li Method incidentEdges() is called once for each vertex BFS runs in O(n + m) time provided the graph is represented by the adjacency list structure The other problems that BFS can solve can also be achieved in O(n + m )Breadth-First Search 15BFS PropertiesNotationGs: connected component of sProperty 1BFS(G, s) visits all the vertices and edges of GsProperty 2The discovery edges labeled by BFS(G, s) form a spanning tree Tsof GsProperty 3For each vertex v in Li The path of  Ts from s to v has iedges  Every path from s to v in Gs has the least number of edges connecting s to v (i.e., shortest path from s to v )CBAEDL0L1FL2CBAEDFBreadth-First Search 16DFS vs. BFSCBAEDL0L1FL2CBAEDFDFS BFSApplications DFS BFSSpanning forest, connected components, paths, cycles √ √Shortest paths √Biconnected components(See next slide for more details)√DFS vs. BFS (cont.)Biconnected components: Two biconnected components of a graph share at most one vertex in common. A vertex is an articulation point if and only if it is common to more than one biconnected component. Example*:17*Source: wikipedia.orgEach color corresponds toa biconnected component. Multi-colored vertices are cut vertices, and thus belong to multiple biconnected components*http://en.wikipedia.org/wiki/Biconnected_componentDFS vs. BFS (cont.)Biconnected componentsAn articulation vertex (or cut vertex) is a vertex whose removal increases the number of connected components. A graph is biconnected if it has no articulation vertices. Articulation points are important for networks since they represent single point of failure. DFS can be used to find the articulation points in a graph and compute its disconnected components in O(n + m) time. Click here for more details (see also the notes section of this slide). Many other good sources are also available both online and offline. CBGADFThe graph has three biconnectedcomponents:{B, C, G},{C, F, D}, and {A, G}C & G are articulation points 18http://en.wikipedia.org/wiki/Biconnected_componentBreadth-First Search 19DFS vs. BFS (cont.)Back edge (v,w) w is an ancestor of v in the tree of discovery edges. For example, A is an ancestor of C (there is a back edge form C to A)Cross edge (v,w) w is in the same level as v or in the next level. wand w are neither ancestors nor descendent in the BFS treeCBAEDL0L1FL2CBAEDFDFS BFS	Breadth-First Search (BFS)	Slide Number 2	Breadth-First Search (BFS)	BFS	BFS Example1	BFS Example1 (cont.)	BFS Example1 (cont.)	BFS Algorithm	BFS Example2	BFS Example2 (cont.)	BFS Example2 (cont.)	BFS Analysis 	BFS Analysis 	BFS Analysis 	BFS Properties	DFS vs. BFS	DFS vs. BFS (cont.)	DFS vs. BFS (cont.)	DFS vs. BFS (cont.)
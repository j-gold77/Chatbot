Analysis of AlgorithmsBucket-Sort and Radix-SortDr. Aiman HannaDepartment of Computer Science & Software Engineering Concordia University, Montreal, CanadaThese slides have been extracted, modified and updated from original slides of :Data Structures and Algorithms in Java, 5th edition. John Wiley& Sons, 2010. ISBN 978-0-470-38326-1.Data Structures and the Java Collections Framework by William J. Collins, 3rdedition, ISBN 978-0-470-48267-4. Both books are published by Wiley.Copyright © 2010-2011 WileyCopyright © 2010 Michael  T. Goodrich, Roberto TamassiaCopyright © 2011 William J. CollinsCopyright © 2011-2021 Aiman Hanna All rights reserved Coverage Bucket-Sort Stable Sorting Radix-Sort20 1 2 3 4 5 6 7 8 9B1, c 7, d 7, g3, b3, a 7, e∅ ∅ ∅ ∅ ∅ ∅ ∅Bucket-Sort and Radix-SortBucket-Sort and Radix-Sort 3Sorting Lower-Bound  As previously shown, with comparison-based sorting, Ω(n log n) time is necessary to sort a sequence of n elements.  The following question can then be asked: Can any other k inds of sorting algorithms be designed to run asymptotically faster than O(n log n)?  Interestingly, such algorithms exist, but they require special assumptions about the input sequence to be sorted.  Even so, such scenarios often exist in practice, so it worthwhile investigating such algorithms.  We will next consider the sorting problem of key-value entries, where the keys have a restricted type.   Bucket-Sort and Radix-Sort 4Bucket-Sort Let S be a sequence of n entries where the keys are always restricted in the range [0, N − 1], for some N >1.   Because of the restrictive assumption about the keys, it is possible to sort without comparisons.  Bucket-sort does not use comparisons; instead it uses the keys as indices into an auxiliary array B of sequences (buckets).  The array B has cells that are indexed from 0 to N – 1.  An entry with key k is placed in the bucket pointed by B[k]. Notice that the bucket pointed by B[k] is hence a sequence of entries that have similar key k.  Bucket-Sort and Radix-Sort 5Bucket-SortPhase 1: Empty sequence S by moving each entry (k, v) into its bucket B[k].Phase 2: For i = 0, …, N − 1, move the entries of bucket B[i] back to the end of  sequence S. Analysis: Phase 1 takes O(n) time Phase 2 takes O(n + N) time Hence, total is O(n + N) If N is O(n), then we can sort in O(n) time.  Bucket-sort can sort in O(n) time; that is clearly lower (better) than O(n log n).  You must notice that the range Nshould not be significantly bigger than n for the algorithm to be efficient. Algorithm bucketSort(S, N)Input sequence S of (key, element)items with keys in the range[0, N − 1]Output sequence S sorted byincreasing keysB ← array of N empty sequenceswhile ¬S.isEmpty()f ← S.first()(k, o) ← S.remove(f)B[k].addLast((k, o))for i ← 0 to N − 1while ¬B[i].isEmpty()f ← B[i].first()(k, o) ← B[i].remove(f)S.addLast((k, o))Bucket-Sort and Radix-Sort 6Example Key range [0, 9]7, d 1, c 3, a 7, g 3, b 7, e1, c 3, a 3, b 7, d 7, g 7, ePhase 1Phase 20 1 2 3 4 5 6 7 8 9B1, c 7, d 7, g3, b3, a 7, e∅ ∅ ∅ ∅ ∅ ∅ ∅Bucket-Sort and Radix-Sort 7Properties and Extensions Key-type Property The keys are used as indices into an array and cannot be arbitrary objects. No external comparator is neededPossible Extensions: Integer keys can be in the range [a - b], which is equal in size to [0 –N-1], but not restricted to [0 – N-1] Simply put entry (k, v) into bucket B[k − a] Example: Keys are 30 to 39. Key 37 is placed in B[37 – 30]; that is B[7].  String keys can also be possible. For instance if the length of the string is the mean of sorting, and the entries have keys with lengths that are always between a minimum and maximum lengths (e.g., names of the 50 U.S. states), then strings can be used as the keys. Bucket-Sort and Radix-Sort 8Stable Sorting Stable Sort Property A sorting algorithm is classified as “stable” if it preserves the original order (in the unsorted sequence) of entries with the same keys when it forms the sorted sequence.  In other words, the relative order of any two items with the same key is preserved after the execution of the algorithm. For instance, if three entries (k2, v3), (k2, v9), and (k2, v5) exist in that order in the unsorted sequences, then the final sorted sequence must also have them in that same order(k2, v3), (k2, v9), then (k2, v5). Bucket-Sort and Radix-Sort 9Stable Sorting Our informal description of bucket-sort does not guarantee stability  We neither restricted how the entries are removed from the unsorted sequence, nor how they we removed from the bucket entry when forming the sorted sequence.  Bucket-sort can be made stable however just by: Enforcing the order of removal of the items from the unsorted sequence from first to last,  Insert these items at the tail of sequences in the buckets  Enforce the removal from the bucket array when forming the sorted sequence  to be from first to last (head to tail).  Generally, stable sorting is important for many applications. Bucket-Sort and Radix-Sort 10Lexicographic Order A d-tuple is a sequence of d keys (k1, k2, …, kd), where key ki is said to be the i-th dimension of the tuple. Example: The Cartesian coordinates of a point in space are a 3-tuple. The lexicographic order of two d-tuples is recursively defined as follows(x1, x2, …, xd) < (y1, y2, …, yd)⇔x1 < y1  ∨ x1 = y1 ∧ (x2, …, xd) < (y2, …, yd) I.e., the tuples are compared by the first dimension, then by the second dimension, etc.Bucket-Sort and Radix-Sort 11Radix-Sort One of the reasons that stable sorting is so important, is that it allows bucket-sort approach to be applied to more general contexts that sorting integers.  For instance, suppose that entries have key pairs (x, y), and not just one key. That  is, an entry looks as follows: ((x, y), v) where the sorting is to be made based on these pairs.  In such cases, it is natural to define an ordering of these keys using lexicographical convention.  That is pair (x1, y1) < (x2, y2) if x1 < x2  or x1 = x1 and y1 < y2 .Bucket-Sort and Radix-Sort 12Radix-Sort Radix-sort algorithm sorts a sequence S of entries with keys that are pairs (or generally d-tuple).  Radix-sort performs that simply by applying a stable bucket-sort on the sequence twice (when the keys are pairs. The application is done d times in the general d-tuple case).  That is, sort first using one of the keys in the pair, then sort again using the other key.  The question however is that: Given entries with key pairs (x1, y1) & (x2, y2), should we first sort based on the first component of the pair (these are the xi keys) then the second component (these are the yi keys) or vise versa? Bucket-Sort and Radix-Sort 13Radix-Sort Example: Let us consider the following sequence S (only the keys are shown) where sorting is needed. S = ((3, 3), (1, 5), (2, 5), (1, 2), (2, 3), (1, 7), (3, 2), (2, 2)) Sorting based on first component then second component will result in the following:  After first component sorting, we have: S = ((1, 5), (1, 2), (1, 7), (2, 5), (2, 3), (2, 2), (3, 3), (3, 2)) Finally, after second component sorting, we end up with: S = ((1, 2), (2, 2), (3, 2), (2, 3), (3, 3), (1, 5), (2, 5), (1, 7))which is clearly NOT lexicographically sorted!Bucket-Sort and Radix-Sort 14Radix-SortExample (continues …): Now let us sorting based on second component then first component will result in the following:  Initial sequence S = ((3, 3), (1, 5), (2, 5), (1, 2), (2, 3), (1, 7), (3, 2), (2, 2)) After first component sorting, we have: S = ((1, 2), (3, 2), (2, 2), (3, 3), (2, 3), (1, 5), (2, 5), (1, 7)) Finally, after second component sorting, we end up with: S = ((1, 2), (1, 5), (1, 7), (2, 2), (2, 3), (2, 5), (3, 2), (3, 3))which is indeed lexicographically sorted. Bucket-Sort and Radix-Sort 15Radix-Sort The previous example led us to believe that the sorting should start by the second component then finish by the first one.  Is that generally the case? Will this always result in the correct behavior? Yes. By first stably sorting by the second component and then by the first component, we guarantee that if two entries have an equal first component key (when applying the second phase of sorting), then their relative order from the first phase is preserved.  Thus, the resulting sequence is guaranteed to be lexicographically sorted every time. Bucket-Sort and Radix-Sort 16Lexicographic-Sort Analysis Let Ci be the comparator that compares two tuples by their i-th dimension. Let stableSort(S, C) be a stable sorting algorithm that uses comparator C. Lexicographic-sort sorts a sequence. of d-tuples in lexicographic order by executing d times algorithm stableSort, one per dimension Lexicographic-sort runs in O(dT(n)) time, where T(n) is the running time of stableSort .Algorithm lexicographicSort(S)Input sequence S of  d-tuplesOutput sequence S sorted inlexicographic orderfor i ← d downto 1stableSort(S, Ci)Example:(7,4,6) (5,1,5) (2,4,6) (2, 1, 4) (3, 2, 4)(2, 1, 4) (3, 2, 4) (5,1,5) (7,4,6) (2,4,6)(2, 1, 4) (5,1,5) (3, 2, 4) (7,4,6) (2,4,6)(2, 1, 4) (2,4,6) (3, 2, 4) (5,1,5) (7,4,6)Bucket-Sort and Radix-Sort 17Radix-Sort Analysis  Again, in the general case, Radix-sort is applicable to d-tuples keys, where the keys in each dimension i  are integers in the range [0, N − 1] for N > 1.  Radix-sort uses sable bucket-sort for each of the d components.   Consequently, Radix-sort runs in time O(d( n + N)). Algorithm radixSort(S, N)Input sequence S of  d-tuples suchthat (0, …, 0) ≤ (x1, …, xd) and(x1, …, xd) ≤ (N − 1, …, N − 1)for each tuple (x1, …, xd) in SOutput sequence S sorted inlexicographic orderfor i ← d downto 1bucketSort(S, N)Bucket-Sort and Radix-Sort 18Radix-Sort for Binary Numbers Consider a sequence of nb-bit integers x = xb − 1 … x1x0 We represent each element as a b-tuple of integers in the range [0, 1] and apply radix-sort with N = 2 This application of the radix-sort algorithm runs in O(bn) time  For example, we can sort a sequence of 32-bit integers in linear timeAlgorithm binaryRadixSort(S)Input sequence S of b-bitintegers Output sequence S sortedreplace each element xof S with the item (0, x)for i ← 0 to b − 1replace the key k of each item (k, x) of Swith bit xi of xbucketSort(S, 2)Bucket-Sort and Radix-Sort 19Example Sorting a sequence of 4-bit integers1001001011010001111000101110100111010001100111010001001011101001000100101101111000010010100111011110	Bucket-Sort and Radix-Sort	Slide Number 2	Sorting Lower-Bound 	Bucket-Sort	Bucket-Sort	Example	Properties and Extensions	Stable Sorting	Stable Sorting	Lexicographic Order	Radix-Sort	Radix-Sort	Radix-Sort	Radix-Sort	Radix-Sort	Lexicographic-Sort Analysis	Radix-Sort Analysis 	Radix-Sort for Binary Numbers	Example
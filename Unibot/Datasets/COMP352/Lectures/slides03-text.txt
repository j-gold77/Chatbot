Analysis of AlgorithmsStacksDr. Aiman HannaDepartment of Computer Science & Software Engineering Concordia University, Montreal, CanadaThese slides have been extracted, modified and updated from original slides of :Data Structures and Algorithms in Java, 5th edition. John Wiley& Sons, 2010. ISBN 978-0-470-38326-1.Data Structures and the Java Collections Framework by William J. Collins, 3rdedition, ISBN 978-0-470-48267-4. Both books are published by Wiley.Copyright © 2010-2011 WileyCopyright © 2010 Michael  T. Goodrich, Roberto TamassiaCopyright © 2011 William J. CollinsCopyright © 2011-2021 Aiman Hanna All rights reserved Stacks 2Abstract Data Types (ADTs) An abstract data type (ADT) is an abstraction/model of a data structure. An abstract data type is defined indirectly, only by the operations that may be performed on it. An ADT specifies:Data storedOperations on the data Error conditions associated with operationsStacks 3Abstract Data Types (ADTs) Example: ADT modeling a simple stock trading system The data stored are buy/sell orders The operations supported are order buy(stock, shares, price) order sell(stock, shares, price) void cancel(order) Error conditions: Buy/sell a nonexistent stock Cancel a nonexistent orderStacks 4The Stack ADT The Stack ADT stores arbitrary objects. Insertions and deletions follow the last-in first-out (LIFO) scheme. Think of a spring-loaded plate dispenser. Formally, a stack is an ADT that supports the following main operations: push(object): inserts an element object pop(): removes and returns the last inserted element Examples: operations of “Back” button on a browser or “undo” on text editors. Stacks 5The Stack ADT Secondary stack operations include: object top(): returns the last inserted element without removing it integer size(): returns the number of elements stored boolean isEmpty(): indicates whether no elements are storedStacks 6The Stack ADT The following table shows a series of stack operations and their effects on an initially empty stack of integers: Operation Output Stack Contentspush(5) -- [5]push(2) -- [5, 2]push(8) -- [5, 2, 8]pop() 8 [5, 2]isEmpty() false [5, 2]top() 2 [5, 2]pop() 2 [5]pop() 5 []pop() ”error” []Stacks 7The Java Built-in Stack Class Because of its importance, Java has a built-in class for the stack (java.util.Stack). The class has various methods, including:  push(), pop(), peek(), empty(), and size().  pop() and peek() throw EmptyStackException if operations are attempted on an empty stack. . While this class is convenient, it is very important to know how to design and implement a Stack class from scratch. http://docs.oracle.com/javase/7/docs/api/java/util/Stack.htmlhttp://docs.oracle.com/javase/7/docs/api/java/util/EmptyStackException.htmlStacks 8Exceptions Attempting the execution of an operation of ADT may sometimes cause an error condition, called an exception. Exceptions are said to be “thrown” by an operation that cannot be executed. In the Stack ADT, operations pop and top cannot be performed if the stack is empty. Attempting the execution of pop or top on an empty stack throws an EmptyStackException.Stacks 9Applications of Stacks Direct applications Page-visited history in a Web browser Undo sequence in a text editor Chain of method calls in the Java Virtual Machine Indirect applications Auxiliary data structure for algorithms Component of other data structuresStacks 10Method Stack in the JVM The Java Virtual Machine (JVM) keeps track of the chain of active methods with a stack. When a method is called, the JVM pushes on the stack a frame containing Local variables and return value Program counter, keeping track of the statement being executed  When a method ends, its frame is popped from the stack and control is passed to the method on top of the stack. Allows for recursion.main() {int i = 5;foo(i);}foo(int j) {int k;k = j+1;bar(k);}bar(int m) {…}barPC = 1m = 6fooPC = 3j = 5k = 6mainPC = 2i = 5Stacks 11Array-based Stack A simple way of implementing the Stack ADT uses an array. We add elements from left to right. A variable keeps track of the  index of the top element.  Initialized to -1 when stack is created.S0 1 2 t…Algorithm size()return t + 1Algorithm pop()if isEmpty() thenthrow EmptyStackExceptionelse t ← t − 1return S[t + 1]Stacks 12Array-based Stack (cont.) The array storing the stack elements may become full. A push operation will then throw a FullStackException Limitation of the array-based  implementation We need to define this class; it is not intrinsic to the Stack ADTS0 1 2 t…Algorithm push(o)if t = S.length − 1 thenthrow FullStackExceptionelse t ← t + 1S[t] ← oStacks 13Performance and Limitations Performance Let n be the number of elements in the stack The space used is O(n) Each operation runs in time O(1) Limitations The maximum size of the stack must be defined a priori and cannot be changed Trying to push a new element into a full stack causes an implementation-specific exceptionStacks 14Array-based Stack in Java*public class ArrayStack<E>implements Stack<E> {// holds the stack elementsprivate E S[ ];// index to top elementprivate int top = -1;// constructorpublic ArrayStack(int capacity) {S = (E[]) new Object[capacity]);}public E pop()throws EmptyStackException {if isEmpty()throw new EmptyStackException(“Empty stack: cannot pop”);E temp = S[top];// facilitate garbage collection:S[top] = null;top = top – 1;return temp;}…  (other methods of Stack interface)* Notice that this is not a built-in Java implementation Stacks 15Example use in Java/** A non-recursive generic method for reversing an array */public static <E> void reverse(E[] a){Stack<E> s = new ArrayStack<E>(a.length);for(int i = 0; i < a.length; i++)s.push(a[i]);for(int i = 0; i < a.length; i++)a[i] = s.pop();}Time complexity is: O(  )Space complexity is: O(  )nnStacks 16Example use in Javapublic class Tester {// … other methodspublic intReverse(Integer a[]) {Stack<Integer> s;s = new ArrayStack<Integer>();… (code to reverse array a) …}public floatReverse(Float f[]) {Stack<Float> s;s = new ArrayStack<Float>();… (code to reverse array f) …}Stacks 17Better Stack Implementation Use linked lists instead of arrays. No need to define a maximum size. When push(), add new element/node at the tail of the list. pop() removes the node at the tail of the list. What is the complexity?Stacks 18Parentheses Matching Each “(”, “{”, or “[” must be paired with a matching “)”, “}”, or “[” correct: ( )(( )){([( )])} correct: ((( )(( )){([( )])} incorrect: )(( )){([( )])} incorrect: ({[ ])} incorrect: (Is it?Stacks 19Parentheses Matching AlgorithmAlgorithm ParenMatch(X,n):Input: An array X of n tokens, each of which is either a grouping symbol, avariable, an arithmetic operator, or a numberOutput: true if and only if all the grouping symbols in X matchLet S be an empty stackfor i=0 to n-1 doif X[i] is an opening grouping symbol thenS.push(X[i])else if X[i] is a closing grouping symbol thenif S.isEmpty() thenreturn false {nothing to match with} if S.pop() does not match the type of X[i] thenreturn false {wrong type} if S.isEmpty() thenreturn true {every symbol matched} else return false {some symbols were never matched}Notice that item is removed hereStacks 20HTML Tag Matching<body><center><h1> The Little Boat </h1></center><p> The storm tossed the littleboat like a cheap sneaker in anold washing machine. The threedrunken fishermen were used tosuch treatment, of course, butnot the tree salesman, who even asa stowaway now felt that hehad overpaid for the voyage. </p><ol><li> Will the salesman die? </li><li> What color is the boat? </li><li> And what about Naomi? </li></ol></body>The Little BoatThe storm tossed the little boatlike a cheap sneaker in an oldwashing machine. The threedrunken fishermen were used tosuch treatment, of course, but notthe tree salesman, who even asa stowaway now felt that he hadoverpaid for the voyage.1. Will the salesman die?2. What color is the boat?3. And what about Naomi?For fully-correct HTML, each <name> should pair with a matching </name>Stacks 21Evaluating Arithmetic Expressions14 – 3 * 2 + 7 = (14 – (3 * 2) ) + 7 Operator precedence* has precedence over +/–Example: x + y * z is:  x + (y * z) rather than (x + y) * zAssociativityoperators of the same precedence groupevaluated from left to rightExample: x – y + z is:  (x – y) + z rather than x – (y + z)Idea: push each operator on the stack, but first pop and perform higher and equal precedence operations.Slide by Matt Stallmann included with permission.Algorithm for Evaluating Expressions22StacksTwo stacks: opStk holds operators Use $ to hold a special “end of input” token with lowest precedenceAlgorithm doOp()x ← valStk.pop();y ← valStk.pop();op ← opStk.pop();valStk.push( y op x )Algorithm repeatOps( refOp )while ( valStk.size() > 1 ∧prec(refOp) ≤prec(opStk.top()) doOp()Algorithm EvalExp()Input: a stream of tokens representing an arithmetic expression (with numbers)Output: the value of the expressionwhile there’s another token zif isNumber(z) then valStk.push(z)else repeatOps(z); opStk.push(z)repeatOps($);    return valStk.top()Force the execution of all remaining operators Stacks 23Algorithm on an Example Expression14  ≤ 4  – 3  *  2  +  7 Operator ≤ has lower precedence than +/––≤144*3–≤1442*3–≤144+2*3–≤144+6–≤144 +≤14-2$7+≤14-2$F$≤145Slide by Matt Stallmann included with permission.Stacks 24Computing Spans (not in book) Using a stack as an auxiliary data structure in an algorithm Given an array X, the spanS[i] of X[i] is the maximum number of consecutive elements X[j] immediately preceding X[i] and such that X[j] ≤ X[i] Spans have applications to financial analysis E.g., stock at 52-week high 6 3 4 5 21 1 2 3 1S012345670 1 2 3 4XStacks 25Quadratic AlgorithmAlgorithm spans1(X, n)Input array X of n integersOutput array S of spans of X #S ← new array of n integers nfor i ← 0 to n − 1 do ns ← 1 nwhile s ≤ i ∧ X[i − s] ≤ X[i] 1 + 2 + …+ (n − 1)s ← s + 1 1 + 2 + …+ (n − 1)S[i] ← s nreturn S 1Algorithm spans1 runs in O(n2) time Stacks 26Computing Spans with a Stack We keep in a stack the indices of the elements visible when “looking back” We scan the array from left to right Let i be the current index We push the index as long as the one prior to it has a smaller value We pop all elements otherwiseEach index of the array Is pushed into the stack exactly once  Is popped from the stack at most once Stack height for the pushed index represents the needed value012345670 1 2 3 4Stacks 27Computing Spans with a Stack ExampleSX0 1 2 3 4 5 6 7 860 30 40 50 20 70 30 80 201 1 2 3 1 2 1 2 10 1indexValue2132121 1 454 4 676 6 8Stacks 28Linear AlgorithmWe iterate on the array n timesEach index is then pushed and popped at most once, which totals to n + nWe record the value at each index of the resulted Span array, which totals to n timesConsequently algorithm spans2 has a complexity of O(n)Stacks 29Growable Array-based Stack In a push() operation, if the stack is full (no more empty locations in the array), we can throw an exception and abort/reject the operation.  Alternatively, we can extend the array; which is actually replacing it with a larger one. How large should the new array be? Incremental strategy: increase the size by a constant c Doubling strategy: double the sizeAlgorithm add(o)if t = S.length − 1 thenA ← new array ofsize …for i ← 0 to t doA[i] ← S[i]S ← At ← t + 1S[t] ← oStacks 30Comparison of the Strategies We compare the incremental strategy and the doubling strategy by analyzing the total time T(n)needed to perform a series of n push() operations. We assume that we start with an empty stack represented by an array of size 1. We refer to the average time taken by a push() operations over the series of operations, i.e.,  T(n)/n, the amortized time of a push() operation.Stacks 31Incremental Strategy Analysis  We need to find the amortized time to perform one push() operation.  That is the total time to perform n push() operations / n. In general, we need to replace the array k = n/c times for all n push() to take place. For instance if n = 100, and c = 4, we need to go through 25 (100/4) replacements for all push() operations to take place.   Notice also that each replacement is larger than the previous one by c. Stacks 32Incremental Strategy Analysis  Consequently, the total time T(n) of a series of n push() operations is proportional to:n + c + 2c + 3c + 4c + … + kc =n + c(1 + 2 + 3 + … + k) =n + ck(k + 1)/2 Since c is a constant, T(n) is O(n + k2), i.e., O(n2). That is  T(n) is the complexity to perform n push() operations. Hence, the amortized time of one single push() operation is O(n). Stacks 33Doubling Strategy Analysis We replace the array k = log2 n times. For instance, to perform 1000 push() operations, we need to expand the array 10 times (1 -> 2 -> 4 -> 8 -> 16 -> 32 -> 64 -> 128 -> 256 -> 512 -> 1024).  The total time T(n) of a series of nadd operations is proportional ton + 1 + 2 + 4 + 8 + …+ 2k =n + 2k + 1 − 1 = n + 2n -1 =3n − 1.geometric series12148Stacks 34Doubling Strategy Analysis Consequently, T(n) (which is needed to perform n push() operations) is O(n). Hence, the amortized time of a single push() operation is O(1). geometric series12148	Stacks	Abstract Data Types (ADTs)	Abstract Data Types (ADTs)	The Stack ADT	The Stack ADT	The Stack ADT	The Java Built-in Stack Class	Exceptions	Applications of Stacks	Method Stack in the JVM	Array-based Stack	Array-based Stack (cont.)	Performance and Limitations	Array-based Stack in Java*	Example use in Java	Example use in Java	Better Stack Implementation	Parentheses Matching	Parentheses Matching Algorithm	HTML Tag Matching	Evaluating Arithmetic �Expressions	Algorithm for �Evaluating Expressions	Algorithm on an �Example Expression	Computing Spans (not in book)	Quadratic Algorithm	Computing Spans with a Stack	Computing Spans with a Stack	Linear Algorithm	Growable Array-based Stack	Comparison of the Strategies	Incremental Strategy Analysis 	Incremental Strategy Analysis 	Doubling Strategy Analysis	Doubling Strategy Analysis
Analysis of AlgorithmsMapsDr. Aiman HannaDepartment of Computer Science & Software Engineering Concordia University, Montreal, CanadaThese slides have been extracted, modified and updated from original slides of :Data Structures and Algorithms in Java, 5th edition. John Wiley& Sons, 2010. ISBN 978-0-470-38326-1.Data Structures and the Java Collections Framework by William J. Collins, 3rdedition, ISBN 978-0-470-48267-4. Both books are published by Wiley.Copyright © 2010-2011 WileyCopyright © 2010 Michael  T. Goodrich, Roberto TamassiaCopyright © 2011 William J. CollinsCopyright © 2011-2021 Aiman Hanna All rights reserved Coverage Maps2Cabinet (Map)Label(Unique Key)Folders(Values)MapsMaps 3Maps A map models a searchable collection of key-value entries. A map allows us to store elements in a way that attempts to speed up the process of locating them, through the utilization of keys.  The main operations of a map are searching, inserting, and deleting items. Multiple entries with the same key are not allowed. In other words, the keys in a map are unique.  Applications: address book student-record databaseMaps 4The Map ADT A map supports the following methods: get(k): if a map M has an entry with key k, return its associated value; else, return null  put(k, v): insert entry (k, v) into the map M; if key k is not already in M, then return null; else, replace the value associated with k with v and return the old value  remove(k): if the map M has an entry with key k, remove it from M and return its associated value; else, return null  entrySet(): return an iterable collection containing all the key-value entries in MMaps 5The Map ADT A map supports the following methods (continues): keySet(): return an iterable collection of all the keys in M values(): return an iterable collection of all the values in M size(): return the number of entries in M isEmpty(): test whether M is emptyMaps 6ExampleOperation Output MapisEmpty() true Øput(5,A) null (5,A)put(7,B) null (5,A),(7,B)put(2,C) null (5,A),(7,B),(2,C)put(8,D) null (5,A),(7,B),(2,C),(8,D)put(2,E) C (5,A),(7,B),(2,E),(8,D)get(7) B (5,A),(7,B),(2,E),(8,D)get(4) null (5,A),(7,B),(2,E),(8,D)get(2) E (5,A),(7,B),(2,E),(8,D)size() 4 (5,A),(7,B),(2,E),(8,D)remove(5) A (7,B),(2,E),(8,D)remove(2) E (7,B),(8,D)get(2) null (7,B),(8,D)isEmpty() false (7,B),(8,D)Maps 7A Simple List-Based Map We can efficiently implement a map using an unsorted list  We store the items of the map in a list S (based on a doubly-linked list), in arbitrary ordertrailerheader nodes/positionsentries9 c 6 c 5 c 8 cMaps 8The get(k) AlgorithmAlgorithm get(k):B = S.positions() {B is an iterator of the positions in S}while B.hasNext() dop = B.next() { the next position in B }if p.element().getKey() = k thenreturn p.element().getValue()return null {there is no entry with key equal to k}Maps 9The put(k,v) AlgorithmAlgorithm put(k,v):B = S.positions()while B.hasNext() dop = B.next()if p.element().getKey() = k  thent = p.element().getValue()S.set(p,(k,v))return t {return the old value}S.addLast((k,v))n = n + 1 {increment variable storing number of entries}return null { there was no entry with key equal to k }Maps 10The remove(k) AlgorithmAlgorithm remove(k):B =S.positions()while B.hasNext() dop = B.next()if p.element().getKey() = k  thent = p.element().getValue()S.remove(p)n = n – 1 {decrement number of entries}return t {return the removed value}return null {there is no entry with key equal to k}Maps 11Performance of a List-Based Map Performance: put takes O(n) time since we need to find out before adding the item if an entry with the key exists (in such case we only replace the value) get and remove take O(n) time since in the worst case (the item is not found) we traverse the entire sequence to look for an item with the given key The unsorted list implementation is effective only for maps of small sizes. 	Maps	Slide Number 2	Maps	The Map ADT	The Map ADT	Example	A Simple List-Based Map	The get(k) Algorithm	The put(k,v) Algorithm	The remove(k) Algorithm	Performance of a List-Based Map
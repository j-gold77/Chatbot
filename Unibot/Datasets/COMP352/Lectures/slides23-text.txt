Analysis of AlgorithmsShortest PathsDr. Aiman HannaDepartment of Computer Science & Software Engineering Concordia University, Montreal, CanadaThese slides have been extracted, modified and updated from original slides of :Data Structures and Algorithms in Java, 5th edition. John Wiley& Sons, 2010. ISBN 978-0-470-38326-1.Data Structures and the Java Collections Framework by William J. Collins, 3rdedition, ISBN 978-0-470-48267-4. Both books are published by Wiley.Copyright © 2010-2011 WileyCopyright © 2010 Michael  T. Goodrich, Roberto TamassiaCopyright © 2011 William J. CollinsCopyright © 2011-2021 Aiman Hanna All rights reserved Coverage Shortest Paths2CBAEDF03285 8487 12 523 9Shortest PathsShortest Paths 3Weighted Graphs Breadth-first search can be used to find the shortest path from one starting vertex to all other ones assuming that all edges in the graph have the same weight (same length, cost, distance, etc.). However, in many situations this may not be the case, and hence BFS is inappropriate.  ORD PVDMIADFWSFOLAXLGAHNLPresenterPresentation NotesNote: If you are wondering whether these distance are actually true, here are these airports; you can check these ditances out!ORD - Chicago O'Hare International AirportPVD - T. F. Green Airport in  Providence, in Kent County, Rhode IslandLGA - LaGuardia Airport - New JerseyDFW - Dallas/Fort Worth International AirportLAX - Los Angeles International AirportSFO - San Francisco International AirportHNL - Honolulu International AirportMIA - Miami International Airport Shortest Paths 4Weighted Graphs Graphs where edges have different weight, are called weighted graphs.  In a weighted graph, each edge has an associated numerical value, called the weight of the edge, which can be different from one edge to another.  Edge weight may represent, distances, costs, etc. For instance, in a  flight route graph, the weight of an edge represents the distance in miles between the endpoint airportsORD PVDMIADFWSFOLAXLGAHNLShortest Paths 5Shortest Paths Given a weighted graph and two vertices u and v, we want to find a path of minimum total weight between u and v. Length of a path is the sum of the weights of its edges. Example: Shortest path between Providence and Honolulu Applications Internet packet routing  Flight reservations Driving directionsORD PVDMIADFWSFOLAXLGAHNLShortest Paths 6Shortest Path PropertiesProperty 1:The length (or weight) of a path is the sum of the weights of the edges composing that pathProperty 2:A subpath of a shortest path is itself a shortest pathProperty 3:There is a tree of shortest paths from a start vertex to all the other verticesExample:Tree of shortest paths from ProvidenceORD PVDMIADFWSFOLAXLGAHNLShortest Paths 7Negative-Weight Cycles The distance from vertex v to vertex u in a graph G, denoted by d(v, u), is the length of the minimum length path (the shortest path) from v to u. d(v, u) = +∞ if there is no path between v and u.  There are cases however where the distance between v and u may not be defined even if there is a path form v to u in G. This is the case if the graph has a negative-weight cycle (a cycle whose total weight is negative).  A negative-weight edge is an edge whose weight is negative.  For instance, assume that the edges in the airport graphs have weights that define the cost to travel between these cities. Further, assume that someone has offered to pay travelers an amount that is larger than the actual cost to travel between PVD and ORD. Shortest Paths 8Negative-Weight Cycles Consequently, the cost from PVD to ORD (that edge e = (PVD, ORD)) would carry a negative value, which makes e = (PVD, ORD) a negative-weight edge.  Further, assume that someone else has then offered travelers to pay an amount that is larger than the actual cost to travel between ORD and PVD.  Consequently, there is now a negative-weight cycle (cycle with a total weight that is negative) between PVD and ORD. These cycles are very undesirable and must be avoided when edge weights are used to represent distances.  Now, the distances of that graph can no longer be defined since someone can build a path from any city A to another B going through PVD and making as many cycles as desired between PVD and ORD before continuing to B. ORD PVDMIADFWSFOLAXLGAHNLShortest Paths 9Dijkstra’s Algorithm Dijkstra’s algorithm computes the distances (the shortest paths) of all the vertices from a given start vertex s Assumptions: the graph is connected the edges are undirected the edge weights are nonnegativeShortest Paths 10Dijkstra’s Algorithm Edge Relaxation: Let us define a label D[u] for each vertex u in the graph, where D[u]stores an approximation of the shortest path distance from a starting vertex v to u.  In other words, D[u] will always store the length of the best path to uthat could have been found so far.  Initially, D[v] = 0, and D[u] = +∞ for each other vertex u in the graph. D[u] will afterwards be updated if a better path is found that results in a smaller shortest path value to u.  The operation is known as relaxation; the idea is similar to stretching a spring more than needed then “relax” it back to its true resting distance. Shortest Paths 11Dijkstra’s Algorithm The idea is to grow a “cloud” of vertices, beginning with the stating vertex s and eventually covering all the vertices In details, the algorithm starts by defining two sets; let us refer to them as the C (for Cloud) set and the S set.  Initially, C is empty, while S has vertex s. Additionally, all the distance approximations, D[u], as initialized as ∞,with the exception of D[v], which is initialized as 0.  Afterwards C will grow to include specific vertices one at a time (those are the ones with concrete shortest paths), while S will include all other vertices that are directly connected either to s or to other vertices already in C. Algorithm terminates once all vertices have been moved to C.Shortest Paths 12Dijkstra’s Algorithm (continues…) In details, the algorithm performs the repeated moving operations from S to C as follows:  Move one vertex from S to C. Let us refer to that vertex as X. This vertex, X, must satisfy the following: 1) It is either directly connected to v or directly connected to another vertex that is already in C2) Has the smallest distance to v among all the potential vertices that are considered for movement to C Whenever the vertex X is moved to C, its distance is the smallest distance (shortest path) to v Additionally, once this vertex X is chosen, move it to C and recheck all distances of all vertices that have direct connection to X and are NOT yet in C. If a smaller value than what we already have is found, update this value In each step, we also update how to go to these vertices (that is, through which vertex); we refer to this vertex as the prior function   The steps are repeated until all the graph vertices are moved to C. The final obtained distances represent the shortest paths, and the prior functions indicate the direction from v (through which vertex) to obtain these shortest paths to each of the other vertices in the graphShortest Paths13Dijkstra’s Algorithm (continues…)Distances to potential vertices Potential vertex with shortest distance X Selected vertex to move to CDifferent routes to u. Is there a cheaper route through X to other vertices in S? If so, update distances to these vertices. vXuSCDistances yet to be determined14Dijkstra’s Algorithm*Figure is © Understanding Data Communications and Networks by William A. Shay - PWS publishing company, Third Edition. ISBN-10: 0534383173, ISBN-13: 978-0534383176. Example: What are the shortest paths from A to other vertices?*15Dijkstra’s AlgorithmC Potential elements of SX A B C D E F A B C D E F0 {} {A} A 0 ∞ ∞ ∞ ∞ ∞ A - - - - -1 {A} {B,C} C 0 2 1 ∞ ∞ ∞ A A A - - -2 {A, C} {B,D,E,F} B 0 2 1 4 7 8 A A A C C C3 {A,B,C} {D,E,F} D 0 2 1 4 6 8 A A A C B C4 {A,B,C,D} {E,F} E 0 2 1 4 6 6 A A A C B D5 {A,B,C,D,E} {F} F 0 2 1 4 6 6 A A A C B DCost function   Prior functionNote: See comments attached to this slide for detailed information on how the operations progressed.  PresenterPresentation NotesNotes: Here are the details of the algorithm’s progress, in case you need to review it after class: Start with the initial set of S including the potential nodes that can be moved (these are either vertices directly connected from A or directly connected through other vertices already in C). At the moment, only A connects to itself, so C:={A}. A is the smallest distance, so it moves to C. Information of A has already been determined (the highlighted parts in yellow will never change or be considered for distance comparison again)Continuing now, the set of S will include all nodes that are directly connected to A; so S:={B,C}Find the smallest cost from A to each one in S; that is B_2 & C_1 (This denotes VertexName_cost-to-it)Now update the cost function and the prior to function. The cost to B is 2, to C is 1 and to all the rest is ∞ since there is no possible connection to them from any node in C. The prior to (think of it as Through) will have A for B and A for C and nothing for the restFind the node with the smallest cost; that will be X step # 1 is now complete  Move the node with the smallest cost to cloud set C. The node with smallest cost now is C, so C:={A,C}  (Notice that the first C is the Cloud set while the later C is node C. The names could not have been any terrible!)Now reconstruct S with all nodes that either with a direct link to A or with a possible connection through one node in C, so S:={B, D, E, F} since B is connected to A and D, E and F are all connected to A through CFind every possible cost from A to the nodes in S; connected either directly from A or through any other node in C; in our case at this moment the only other node is C   The costs are as follows: (VertexName_cost-through) B_2-a, D_4-c, E_7-c, F_8-c Choose the smallest distance and set its vertex as X; this is also what will move next to C. We must also update the prior function if we find a smallest cost for any of the vertices compared to the previous step. Now B has the smallest Cost and so it set as X. The smallest cost is now updated to be 2 for B, 1 for C, 4 for D, 7 for E and 8 for F. The prior function will also be reflected as a result, so the prior for B is A, for C is A, for D is C, for E is C and for F is C. Now move B to C and start Step 3 At that level, the costs are as follows: D_5-b, D_4-c, E_6-b, E_7-c, F_9-b, F_8-c. The smallest is D_4 through C. This concludes that D will move next to C. However if you look at E, now there is smaller cost through B (that is 6) compared to the last step, which was 7 through C. As a result, we must update the prior to E to be B instead of C. Now X is set to D and D will move to C and start step 4.  The rest is identical, and so it should be straight forward. In general, you will find in step 4 that the values are:	E_6-b, E_7-c, E_12-cd (that is through D, which is through C as prior) is C), F_9-b, F_8-c, F_6-cd. Now we have a tie between E_6-b and F_6-cd; just pick up any of them as smallest. In our solutions we picked E_6-b as smallest and so we set it as X and moved it to C when step 5 starts. In the last step we have the following values: F_9-b, F_8-c, F_6-cd, F_12-be, and so the prior of F is set as D with a smallest cost of 6. Shortest Paths 16Edge Relaxation Consider an edge e = (u,z)such that u is the vertex most recently added to the cloud z is not in the cloud The relaxation of edge e updates distance d(z) as follows:d(z) ← min{d(z),d(u) + weight(e)}d(z) = 75d(u) = 50zsud(z) = 60d(u) = 50zsueevd(v) = 40vd(v) = 40Shortest Paths 17Example 2 – Visual ApproachCBAEDF0428∞ ∞487 12 523 9CBAEDF03285 11487 12 523 9CBAEDF03285 8487 12 523 9CBAEDF03275 8487 12 523 9Shortest Paths 18Example 2 (cont.)CBAEDF03275 8487 12 523 9CBAEDF03275 8487 12 523 9Shortest Paths 19Dijkstra’s Algorithm A heap-based adaptable priority queue with location-aware entries stores the vertices outside the cloud Key: distance Value: vertex Recall that method replaceKey(l,k) changes the key of entry l We store two labels with each vertex: Distance Entry in priority queueAlgorithm DijkstraDistances(G, s)Q ← new heap-based priority queuefor all v ∈ G.vertices()if v = ssetDistance(v, 0)elsesetDistance(v, ∞)l ← Q.insert(getDistance(v), v)setEntry(v, l)while ¬Q.isEmpty()l ← Q.removeMin()u ← l.getValue()for all e ∈ G.incidentEdges(u) { relax e }z ← G.opposite(u,e)r ← getDistance(u) + weight(e)if r < getDistance(z)setDistance(z,r)Q.replaceKey(getEntry(z), r)Shortest Paths 20Analysis of Dijkstra’s Algorithm Initial operations (the 1st for all loop) Method setDistance is called once for each vertex, resulting in O(n) Method setEntry is called once for each vertex, resulting in O(n) Each vertex is then inserted into the Heap-based Priority Queue, where each insertion costs O(log n), resulting in a total of O(n log n) Removal from Priority queue (the while loop)  Each vertex is removed once from the priority queue, where each removal takes O(log n) time, resulting in a total of O(n log n) Method getValue is called once for each vertex, resulting in O(n) so far, complexity is O(2 n log n) O(n log n) Shortest Paths 21Analysis of Dijkstra’s Algorithm Following all incident edges of removed vertex (the inner forloop)  Now, the method incidentEdges is called for every removed vertex u, which means that the method is called as many times as the degree of that vertex u, resulting in O(deg(u)), provided the graph is represented by the adjacency list structure.  Since all vertices are removed one by one, and sicne each will cost O(deg(v)) of that vertex v, a total of O(Σv deg(v)) for all vertices is eventually incurred. What happens however, each time you follow one of the incident edges of u ?Shortest Paths 22Analysis of Dijkstra’s Algorithm What happens however, each time you follow one of the incident edges of u ? The methods: opposite, getDistance, weight, and setDistance are called, however each of these cost O(1) BUT …… The method replaceKey, which affects the values of the key in the heap, may result in O(log n) operations since the heap may need to be corrected each time  This consequently results in O(log n) for each incident edge Since incidentEdges method is eventually called O(Σv deg(v)), since all vertices are removed, a total complexity of O(Σv deg(v) log n) is incurredShortest Paths 23Analysis of Dijkstra’s Algorithm So, what is the total complexity? From initial operations and insertion into the queue, we have:O(n log n) From following all the incident edges, we have O(Σv deg(v) log n)Recall that Σv deg(v) = 2m O(Σv deg(v) log n) = O(2m log n)  O(m log n) So, total complexity of Dijkstra’s algorithm is: O(n log n) + O(m log n) O((n + m) log n)Shortest Paths 24Analysis of Dijkstra’s Algorithm In conclusion, Dijkstra’s algorithm runs in O((n + m) log n)provided the graph is represented by the adjacency list structure. The running time can also be expressed as a function of n only asO(n2 log n) Recall that m <= n(n-1)/2Shortest Paths 25Shortest Paths Tree Using the template method pattern, we can extend Dijkstra’s algorithm to return a tree of shortest pathsfrom the start vertex to all other vertices We store with each vertex a third label: parent edge in the shortest path tree In the edge relaxation step, we update the parent labelAlgorithm DijkstraShortestPathsTree(G, s)…for all v ∈ G.vertices()…setParent(v, ∅)…for all e ∈ G.incidentEdges(u){ relax edge e }z ← G.opposite(u,e)r ← getDistance(u) + weight(e)if r < getDistance(z)setDistance(z, r)setParent(z,e)Q.replaceKey(getEntry(z),r)Shortest Paths 26Why Dijkstra’s Algorithm Works Dijkstra’s algorithm is based on a method called the greedy method. It adds vertices by increasing distance. Assume that vertex u is the firstvertex that was incorrectly picked up to enter the cloud  By that time, both v (the starting vertex), and y (a correctly picked up vertex) are already in the cloud However, assume that the algorithm misbehaves such that it has incorrectly picked up u to enter the cloud without having a correct shortest pathvPD[y] = d(v, y)CyuzD[z] = d(v, z)D[u] > d(v, u)The first wrong vertex with a path longer than the shortest pathShortest Paths27Why Dijkstra’s Algorithm Works Since u was chosen by error, then D[u] > d(v, u) Let then back a bit on time to the moment when y was added to the cloud.  At that time, we must have evaluated the relaxed distance to z, D[z], and possibly have updated it to reflect the current known shortest path to z.  Consequently, at this point we had: D[z] <= D[y] + w((y, z))  D[z] <= d(v, y)+ w((y, z)) vPD[y] = d(v, y)CyuzD[z] = d(v, z)D[u] > d(v, u)The first wrong vertex with a path longer than the shortest pathShortest Paths28Why Dijkstra’s Algorithm Works But, since z is indeed having a correct shortest path (recall that u is he first incorrect vertex) then D[z] = d(v, z) But since now the algorithm is picking up u not z, it must have found that:D[u] <= D[z] Recall that a shortest path is composed  of shortest sub-paths. Hence, since z is in the shortest path, P, from v to u then:d(v, z)+ d(z, u) = d(v, u)vPD[y] = d(v, y)CyuzD[z] = d(v, z)D[u] > d(v, u)The first wrong vertex with a path longer than the shortest pathShortest Paths29Why Dijkstra’s Algorithm Works Moreover, d(z, u) > 0 since there are no negative edges Therefore:D[u] <= D[z] = d(v, z) d(v, z) <= d(v, z) + d(z, u) d(v, z) <= d(v, u) D[u] <= d(v, u) However this contradicts our original definition of u and assumption that D[u] > d(v, u)  Which means that there can never be such a vertex u. vPD[y] = d(v, y)CyuzD[z] = d(v, z)D[u] > d(v, u)The first wrong vertex with a path longer than the shortest pathShortest Paths 30Why It Doesn’t Work for Negative-Weight Edges If a node with a negative incident edge were to be added late to the cloud, it could mess up distances for vertices already in the cloud. CBAEDF04575 9487 12 560 -8Dijkstra’s algorithm is based on the greedy method. It adds vertices by increasing distance.C’s true distance is 1, but it is already in the cloud with d(C)=5 and possibly has already affected many other distances!Shortest Paths 31Bellman-Ford Algorithm (not in book) Works even with negative-weight edges Must assume directed edges (for otherwise we would have negative-weight cycles) Iteration i finds all shortest paths that use i edges. Running time: O(nm). Can be extended to detect a negative-weight cycle if it exists  How?Algorithm BellmanFord(G, s)for all v ∈ G.vertices()if v = ssetDistance(v, 0)elsesetDistance(v, ∞)for i ← 1 to n − 1 dofor each e ∈ G.edges(){ relax edge e }u ← G.origin(e)z ← G.opposite(u,e)r ← getDistance(u) + weight(e)if r < getDistance(z)setDistance(z,r)Shortest Paths 32∞-2Bellman-Ford Example∞∞0∞∞∞487 1-2 5-23 9∞0∞∞∞487 1-2 53 9Nodes are labeled with their d(v) values-2-2804∞487 1-2 53 9∞8 -2 4-15619-2501-19487 1-2 5-23 94Shortest Paths 33DAG-based Algorithm (not in book) Works even with negative-weight edges Uses topological order Doesn’t use any fancy data structures Is much faster than Dijkstra’s algorithm Running time: O(n+m).Algorithm DagDistances(G, s)for all v ∈ G.vertices()if v = ssetDistance(v, 0)elsesetDistance(v, ∞){ Perform a topological sort of the vertices }for u ← 1 to n do    {in topological order}for each e ∈ G.outEdges(u){ relax edge e }z ← G.opposite(u,e)r ← getDistance(u) + weight(e)if r < getDistance(z)setDistance(z,r)Shortest Paths 34∞-2DAG Example∞∞0∞∞∞487 1-5 5-23 9∞0∞∞∞487 1-5 53 9Nodes are labeled with their d(v) values-2-2804∞487 1-5 53 9∞-2 4-11 7-2501-17487 1-5 5-23 9412 436 512 436 5812 436 512 436 550(two steps)	Shortest Paths	Slide Number 2	Weighted Graphs	Weighted Graphs	Shortest Paths	Shortest Path Properties	Negative-Weight Cycles	Negative-Weight Cycles	Dijkstra’s Algorithm	Dijkstra’s Algorithm	Dijkstra’s Algorithm	Dijkstra’s Algorithm (continues…)	Dijkstra’s Algorithm (continues…)	Dijkstra’s Algorithm	Dijkstra’s Algorithm	Edge Relaxation	Example 2 – Visual Approach	Example 2 (cont.)	Dijkstra’s Algorithm	Analysis of Dijkstra’s Algorithm	Analysis of Dijkstra’s Algorithm	Analysis of Dijkstra’s Algorithm	Analysis of Dijkstra’s Algorithm	Analysis of Dijkstra’s Algorithm	Shortest Paths Tree	Why Dijkstra’s Algorithm Works	Why Dijkstra’s Algorithm Works	Why Dijkstra’s Algorithm Works	Why Dijkstra’s Algorithm Works	Why It Doesn’t Work for Negative-Weight Edges	Bellman-Ford Algorithm �(not in book)	Bellman-Ford Example	DAG-based Algorithm �(not in book)	DAG Example
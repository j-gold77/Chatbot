Analysis of AlgorithmsDirected Graphs (digraphs)Dr. Aiman HannaDepartment of Computer Science & Software Engineering Concordia University, Montreal, CanadaThese slides have been extracted, modified and updated from original slides of :Data Structures and Algorithms in Java, 5th edition. John Wiley& Sons, 2010. ISBN 978-0-470-38326-1.Data Structures and the Java Collections Framework by William J. Collins, 3rdedition, ISBN 978-0-470-48267-4. Both books are published by Wiley.Copyright © 2010-2011 WileyCopyright © 2010 Michael  T. Goodrich, Roberto TamassiaCopyright © 2011 William J. CollinsCopyright © 2011-2021 Aiman Hanna All rights reserved DiGraphsCoverage Directed Graphs (digraphs) Traversal of digraphs Transitive Closure  Directed Acyclic Graphs (DAGs) 2JFKBOSMIAORDLAXDFWSFODiGraphs 3Digraphs A digraph is a graph whose edges are all directed Short for “directed graph” Applications one-way streets flights task scheduling ACEBDDiGraphs 4Digraph Properties A graph G=(V,E) such that Each edge goes in one direction Edge (a,b) goes from a to b, but not b to a We usually refer to direct graph G as G If G is simple, m < n⋅(n − 1) We can have two directed edges between each two nodes (these are in opposite directions and not parallel since the graph is simple). Consequently, maximum degree at any vertex is 2(n-1); n-1 incomingand n-1 outgoing If we keep in-edges and out-edges in separate adjacency lists, we can perform listing of incoming edges and outgoing edges in time proportional to their sizeACEBDDiGraphs 5Digraph Application Scheduling: edge (a,b) means task a must be completed before b can be startedThe good lifeics141ics131 ics121ics53 ics52ics51ics23ics22ics21ics161ics151ics171DiGraphs 6Reachability One of the fundamental issues with digraphs is the notion of reachability Given two vertices w and u in graph G, we say that wreaches u, or u is reachable from w, if G has a directed path from w to u We also say that vertex v reaches an edge (w, z) if vreaches w and w is the origin of that edgeDiGraphs 7Reachability Examples: Which vertex reaches which vertices?ACEBDFACE DACEBDFDiGraphs 8Strong Connectivity A digraph G is strongly connected if for any two vertices u and v in the graph, u reaches v and v reaches u In other words, each vertex can reach all other vertices A directed cycle is a cycle where all the edges are traversed in their respective directions  A graph is acyclic if it has no directed cyclesadcbefgDiGraphs 9Transitive Closure Given a digraph G, the transitive closure of G is the digraph G* such that G* has the same vertices as G if G has a directed path from u to v (u ≠ v), G*has a directed edge from u to v The transitive closure provides reachability information about a digraphBADCEBADCEGG*DiGraphs 10Digraph Traversal  We can specialize the traversal algorithms (DFS and BFS) to digraphs by traversing edges only along their direction In the directed DFS algorithm, we have four types of edges (the last three are non-tree edges) discovery edges (edges that led us to discover new vertices; these are the tree edges) back edges (connect a vertex to its ancestor) forward edges (connect a vertex to its descendant) cross edges (connect an edge to another one who is neither ancestor no descendant) A directed DFS starting at a vertex sdetermines the vertices reachable from sACEBDDiGraphs 11Digraph Traversal  Example: Showing intermediate step where the traversal started from BOS and the “already previously  visited” DFW is reached for the first timeJFKBOSMIALAXDFWSFOORDDiGraphs 12Digraph Traversal JFKBOSMIALAXDFWSFOORD Example (continues…):DiGraphs 13Digraph Traversal JFKBOSMIALAXDFWSFOORD Example (continues…):DiGraphs 14Digraph Traversal JFKBOSMIALAXDFWSFOORD Example (continues…):DiGraphs 15Digraph Traversal JFKBOSMIALAXDFWSFOORD Example (continues…):DiGraphs 16Digraph Traversal JFKBOSMIALAXDFWSFOORD Example (continues…):DiGraphs 17Digraph Traversal JFKBOSMIALAXDFWSFOORD Example (continues…):DiGraphs 18Digraph Traversal JFKBOSMIALAXDFWSFOORD Example (continues…):DiGraphs 19Digraph Traversal JFKBOSMIALAXDFWSFOORD Example (continues…):DiGraphs 20Digraph Traversal JFKBOSMIALAXDFWSFOORD Example (continues…):DiGraphs 21Digraph Traversal JFKBOSMIALAXDFWSFOORD Example (continues…):DiGraphs 22Digraph Traversal  Example (continues…): Completed DFSJFKBOSMIALAXDFWSFOORD1234567Digraph DFS Analysis Directed DFS over a graph G: Starting at vertex s, DFS visits all vertices that are reachable from s (Notice that these may NOT be all vertices of G) Can be proven by contradiction as we have done with undirected DFS Starting for a vertex s, DFS runs in O(ns + ms), where ns and msare the reachable vertices and edges from s.  A recursive call is needed once for each vertex, and each edge is traversed once from its origin Can find/compute the transitive closure of G. This can be done as follows:  Find all the vertices reachable form a vertex s Add edges from that vertex s to the ones that it reaches if such edges do not exist  Repeat the operation for each vertex v in the graphDigraph DFS Analysis (Continue…) Directed DFS over a graph G: Test if G is strongly connected. This can be done as follows:  Perform repeated DFS traversal operations starting from each vertex in G If each DFS visits all the vertices in G then G is strongly connected DFS complexity to find transitive closure or strong connectivity is: Each run takes O(n + m) We perform these runs n times O(n(n + m))Digraph DFS Analysis (Continue…) In fact, strong connectivity can be tested much faster than that (by only using 2 DFSs) as follows: Start at any vertex s and perform DFS  If s does not visit all the vertices then the graph is not strongly connected If s reaches all vertices then reverse all edges in G (or change the algorithm to treat them as if they were reversed) and run DFS again starting from s If this second run reaches all the vertices, then G is strongly connected; otherwise it is not (since not each vertex can reach s!) Proof: from first run s can reaches all vertices. From second run, all vertices reach s, but s can reach all vertices (from first run!). Consequently each vertex can reach all other vertices in G These will takes O(2(n + m))  O(n + m)25DiGraphsDiGraphs 261. Pick a vertex v in G2. Perform a DFS from v in Ga. If there is a vertex w that is not visited, print “no strong connectivity”3. Let G’ be G with edges reversed4. Perform a DFS from v in G’a. If there is a vertex w that is not visited, print “no strong connectivity”b. Else, print “Graph is strongly connected”Strong Connectivity AlgorithmG:G’:adcbefgadcbefgDiGraphs 27 Maximal subgraphs such that each vertex can reach all other vertices in these subgraphs Can also be done in O(n+m) time using DFS, but is more complicated (similar to biconnectivity).Strongly Connected Components{ a , c , g }{ f , d , e , b }adcbefgDiGraphs 28Computing the Transitive Closure We can perform DFS starting at each vertex O(n(n+m))If there's a way to get  from A to B and from        B to C, then there's a        way to get from A to C.Alternatively ... Use dynamic programming: The Floyd-Warshall AlgorithmDiGraphs 29Floyd-Warshall Transitive Closure The idea is as follows: Let G be a digraph with n vertices and m edges Compute the transitive closure in a series of rounds as follows: Initialize G0 = G Arbitrary number the vertices v1 to vn Start the computation from round 1 For any round k, we construct digraph Gk starting from Gk = Gk-1 If Gk-1 contains both direct edges (vi , vk) and (vk , vj), then add a direct edge (vi , vj) to Gk if it is not already there G* = GnDiGraphs 30Floyd-Warshall Transitive Closure The algorithm is known as the Floyed-Warshall algorithm and it belongs to an algorithmic design pattern known as dynamic programmingkjiFor i Use only verticesnumbered 1,…,k-1 For j Use only verticesnumbered 1,…,k-1Uses only vertices numbered 1,…,k(add this edge if it’s not already in)DiGraphs 31Floyd-Warshall’s AlgorithmAlgorithm FloydWarshall(G)Input digraph GOutput transitive closure G* of Gi ← 1for all v ∈ G.vertices()denote v as vii ← i + 1G0 ← Gfor k ← 1 to n doGk ← Gk − 1for i ← 1 to n (i ≠ k) dofor j ← 1 to n (j ≠ i, j ≠ k) doif Gk − 1.areAdjacent(vi, vk) ∧Gk − 1.areAdjacent(vk, vj)if ¬Gk.areAdjacent(vi, vj)Gk.insertDirectedEdge(vi, vj , k)return GnDiGraphs 32Floyd-Warshall’s Analysis  Running time:  Assuming that areAdjacent() is O(1) and insertDirectedEdge()is O(1) , which can be achieved using adjacency matrix, Floyed-Warshall has a complexity of O(n3) Notice the three loops in the algorithm Running DFS seems to be faster than Floyed-Warshall, however:  If the graph is represented by adjacency matrix then one run of DFS would take O(n2), which means to compute the transitive closure would require O(n3) since DFS needs to run n times If this is the case, then running Floyed-Warshall once may be preferable than running DFS n times since after all both will have the same complexity of O(n3) DiGraphs 33Floyd-Warshall ExampleJFKBOSMIAORDLAXDFWSFOv2v1v3v4v5v6v7DiGraphs 34Floyd-Warshall, Iteration 1JFKBOSMIAORDLAXDFWSFOv2v1v3v4v5v6v7DiGraphs 35Floyd-Warshall, Iteration 2JFKBOSMIAORDLAXDFWSFOv2v1v3v4v5v6v7DiGraphs 36Floyd-Warshall, Iteration 3JFKBOSMIAORDLAXDFWSFOv2v1v3v4v5v6v7DiGraphs 37Floyd-Warshall, Iteration 4JFKBOSMIAORDLAXDFWSFOv2v1v3v4v5v6v7DiGraphs 38Floyd-Warshall, Iteration 5JFKMIAORDLAXDFWSFOv2v1v3v4v5v6v7BOSDiGraphs 39Floyd-Warshall, Iteration 6JFKMIAORDLAXDFWSFOv2v1v3v4v5v6v7BOSDiGraphs 40Floyd-Warshall, ConclusionJFKMIAORDLAXDFWSFOv2v1v3v4v5v6v7BOSDiGraphs 41Directed Acyclic Graphs (DAGs) A directed acyclic graph (DAG) is a digraph that has no directed cycles In practice, there are many applications of DAGs, including: Inheritance relation between classes (i.e. in Java) Prerequisites between courses in an academic program  Schedule constraints between tasks of a project (i.e. setup electric wires before testing lights, or fix walls in place before painting them)DiGraphs 42DAGs and Topological Ordering Given a digraph G, a topological ordering of G  is an ordering of v1 , …, vnof the vertices of G such that for every edge (vi , vj), we have i < j Example: Course v1 must be taken before course v3 and course v2must be taken before v3 and v4, and so onTheoremA digraph admits a topological ordering if and only if it is a DAGBADCEDAG GBADCETopological ordering of Gv1v2v3v4 v5DiGraphs 43write c.s. programplayTopological Sorting Number vertices, so that (u,v) in E implies u < vwake upeatnapstudy computer sci.more c.s.work outsleepdream about graphsA typical student day12 34 567891011bake cookiesDiGraphs 44 Many algorithms can be used to calculate the topological ordering (to sort the vertices) One algorithm can be as follows: assume a DAG G:  Since G is acyclic then there must exist at least one vertex v such as v has no incoming edges (indeg(v) = 0)  If v is removed, then the resulting graph must still be acyclic, which means, there exist another vertex w in the remaining graph such as indeg(w) = 0 Give v sorting # 1, then remove it Find another vertex w with deg(w) = 0, set its sorting # to 2 and remove Repeat the above operations until all vertices are sorted Running time: O(n + m) The algorithm traverses all the outgoing edges for each visited vertex once, so its running time is proportionate to the number of outgoing edges of the verticesAlgorithm for Topological SortingDiGraphs 45Topological Sorting ExampleNote that there is more than one possible solutionAGDFEBCHx       ysorting #indeg()? 0? 1? 1? 2? 3? 2? 0? 3Current removed vertex/edgesPreviously removed vertex/edgesDiGraphs 46Topological Sorting Example (continues…)AGDFEBCHx       ysorting #indeg()1 0? 0? 1? 2? 3? 2? 0? 2Current removed vertex/edgesPreviously removed vertex/edgesDiGraphs 47Topological Sorting Example (continues…)AGDFEBCHx       ysorting #indeg()1 02 0? 0? 2? 2? 2? 0? 1Current removed vertex/edgesPreviously removed vertex/edgesDiGraphs 48Topological Sorting Example (continues…)AGDFEBCHx       ysorting #indeg()1 02 03 0? 1? 2? 2? 0? 1Current removed vertex/edgesPreviously removed vertex/edgesDiGraphs 49Topological Sorting Example (continues…)AGDFEBCHx       ysorting #indeg()1 02 03 0? 1? 2? 14 0? 0Current removed vertex/edgesPreviously removed vertex/edgesDiGraphs 50Topological Sorting Example (continues…)AGDFEBCHx       ysorting #indeg()1 02 03 0? 1? 2? 04 05 0Current removed vertex/edgesPreviously removed vertex/edgesDiGraphs 51Topological Sorting Example (continues…)AGDFEBCHx       ysorting #indeg()1 02 03 0? 0? 16 04 05 0Current removed vertex/edgesPreviously removed vertex/edgesDiGraphs 52Topological Sorting Example (continues…)AGDFEBCHx       ysorting #indeg()1 02 03 07 0? 06 04 05 0Current removed vertex/edgesPreviously removed vertex/edgesDiGraphs 53Topological Sorting Example (continues…)AGDFEBCHx       ysorting #indeg()1 02 03 07 08 06 04 05 0Current removed vertex/edgesPreviously removed vertex/edgesDiGraphs 54 Work it the other way around:  find a vertex with no outgoing edge (outdeg(v) = 0) and give it # n, then remove it  find another one w with (outdeg(w) = 0) and give it # n-1, then remove it  Repeat until all vertices are sorted Running time is still O(n + m) Note: This algorithm is different than the one in the bookOther Algorithms for Topological SortingAlgorithm TopologicalSort(G)H ← G // Temporary copy of Gn ← G.numVertices()while H is not empty doLet v be a vertex with no outgoing edgesLabel v ← nn ← n − 1Remove v from HDiGraphs 55Implementation with DFS Simulate the algorithm by using depth-first search O(n+m) time.Algorithm topologicalDFS(G, v)Input graph G and a start vertex v of GOutput labeling of the vertices of Gin the connected component of vsetLabel(v, VISITED)for all e ∈ G.outEdges(v) { outgoing edges }w ← opposite(v,e)if getLabel(w) = UNEXPLORED{ e is a discovery edge }topologicalDFS(G, w)else{ e is a forward or cross edge }Label v with topological number nn ← n - 1Algorithm topologicalDFS(G)Input dag GOutput topological ordering of Gn ← G.numVertices()for all u ∈ G.vertices()setLabel(u, UNEXPLORED)for all v ∈ G.vertices()if getLabel(v) = UNEXPLOREDtopologicalDFS(G, v)DiGraphs 56DFS Topological Sorting Example The sorting # will always be assigned to a vertex just before the vertex rolls back to its previous vertex Notice however that the algorithm applies DFS also starting from each  of the vertices that have only outgoing edges on the graph, which is important to guarantee all vertices will get their numbering  i,e. See how the sorting number for the vertex with final assigned # 1 is givenDiGraphs 57DFS Topological Sorting Example 9DiGraphs 58DFS Topological Sorting Example89DiGraphs 59DFS Topological Sorting Example789DiGraphs 60DFS Topological Sorting Example 7869DiGraphs 61DFS Topological Sorting Example78569DiGraphs 62DFS Topological Sorting Example748569DiGraphs 63DFS Topological Sorting Example7485639DiGraphs 64DFS Topological Sorting Example27485639DiGraphs 65DFS Topological Sorting Example274856139	Directed Graphs (digraphs)	Slide Number 2	Digraphs	Digraph Properties	Digraph Application	Reachability	Reachability	Strong Connectivity	Transitive Closure	Digraph Traversal 	Digraph Traversal 	Digraph Traversal 	Digraph Traversal 	Digraph Traversal 	Digraph Traversal 	Digraph Traversal 	Digraph Traversal 	Digraph Traversal 	Digraph Traversal 	Digraph Traversal 	Digraph Traversal 	Digraph Traversal 	Digraph DFS Analysis	Digraph DFS Analysis (Continue…)	Digraph DFS Analysis (Continue…)	Strong Connectivity Algorithm	Strongly Connected Components	Computing the Transitive Closure	Floyd-Warshall Transitive Closure	Floyd-Warshall Transitive Closure	Floyd-Warshall’s Algorithm	Floyd-Warshall’s Analysis 	Floyd-Warshall Example	Floyd-Warshall, Iteration 1	Floyd-Warshall, Iteration 2	Floyd-Warshall, Iteration 3	Floyd-Warshall, Iteration 4	Floyd-Warshall, Iteration 5	Floyd-Warshall, Iteration 6	Floyd-Warshall, Conclusion	Directed Acyclic Graphs (DAGs)	DAGs and Topological Ordering	Topological Sorting	Algorithm for Topological Sorting	��Topological Sorting Example�Note that there is more than one possible solution	Topological Sorting Example (continues…) 	Topological Sorting Example (continues…) 	Topological Sorting Example (continues…) 	Topological Sorting Example (continues…) 	Topological Sorting Example (continues…) 	Topological Sorting Example (continues…) 	Topological Sorting Example (continues…) 	Topological Sorting Example (continues…) 	Other Algorithms for Topological Sorting	Implementation with DFS	DFS Topological Sorting Example 	DFS Topological Sorting Example 	DFS Topological Sorting Example 	DFS Topological Sorting Example 	DFS Topological Sorting Example 	DFS Topological Sorting Example 	DFS Topological Sorting Example 	DFS Topological Sorting Example 	DFS Topological Sorting Example 	DFS Topological Sorting Example 
Analysis of AlgorithmsRecursion 1RecursionDr. Aiman HannaDepartment of Computer Science & Software Engineering Concordia University, Montreal, CanadaThese slides have been extracted, modified and updated from original slides of :Data Structures and Algorithms in Java, 5th edition. John Wiley& Sons, 2010. ISBN 978-0-470-38326-1.Data Structures and the Java Collections Framework by William J. Collins, 3rdedition, ISBN 978-0-470-48267-4. Both books are published by Wiley.Copyright © 2010-2011 WileyCopyright © 2010 Michael  T. Goodrich, Roberto TamassiaCopyright © 2011 William J. CollinsCopyright © 2011-2021 Aiman Hanna All rights reserved Recursion 2The Recursion Pattern Recursion: when a method calls itself Classic example: the factorial function:n! = 1* 2 * 3 * ··· * (n-1) * n Recursive definition: As a Java method:// recursive factorial functionpublic static int  recursiveFactorial(int n) { if  (n  ==  0)  return  1; // base caseelse return  n  *  recursiveFactorial(n- 1); // recursive case}−⋅==elsenfnnnf)1(0 if1)(Content of a Recursive Method Base case(s) Also referred to as stopping cases. These are the cases where the method performs NO more recursive calls.  There should be at least one base case.  Every possible chain of recursive calls musteventually reach a base case. Recursive calls Calls to the method itself.  Each recursive call should be defined so that it makes progress towards a base case.Recursion 3Visualizing Recursion Recursion trace A box for each recursive call An arrow from each caller to callee An arrow from each callee to caller showing return value See Recursion1.javaRecursion2.java ExampleRecursion 4recursiveFactorial (4)recursiveFactorial (3)recursiveFactorial (2)recursiveFactorial (1)recursiveFactorial (0)return 1callcallcallcallreturn 1*1 = 1return 2*1 = 2return 3*2 = 6return 4*6 = 24 final answercallhttp://www.aimanhanna.com/concordia/comp249/Recursion1.java.dochttp://www.aimanhanna.com/concordia/comp249/Recursion2.java.docRecursion 5Recursion & The Stack A running Java program maintains a private memory area called the stack, which is used to keep track of the methods as they are invoked.  Whenever a method is invoked, its information (parameters, local variables, Program Counter (PC), …) is placed as one frame into the stack.  The frame is removed from the stack once the method returns. Recursion 6Recursion & The Stackmain():PC = 24x = 10fun1():PC = 229y = 7fun5():PC = 328m = 2n = 5Frames Java Stack main(){ …fun1();…}fun1(){ …fun5();…}Recursion 7Recursion & The Stack The heap is another memory area that is maintained for a running program. The heap is used for dynamic allocation of memory at runtime (i.e. when new is called to create an object). Usually the stack and the heap grow against each other in the memory.  Recursion has hence the potential of overflowing the stack by quickly consuming all available space.   See Recursion3.javahttp://www.aimanhanna.com/concordia/comp249/Recursion3.java.docLinear Recursion Simplest form of recursion, where the method makes at most one recursive call each time it is invoked.  Very useful when the problem is viewed in terms of first or last element, plus a remaining set that has the same structure as the original set.  For instance, obtaining the summation of n values in an array can be viewed as: Obtaining the sum of the first n-1 elements plus the value of the last element; If the array has only one element, then the summation is that single value, A[0] . 8RecursionRecursion 9Example of Linear RecursionAlgorithm LinearSum(A, n):Input: An integer array A and an integer n >= 1, such that A has at least n elementsOutput: The sum of the first n integers in Aif n = 1 thenreturn A[0]elsereturn LinearSum(A, n - 1) + A[n - 1]Example recursion trace:LinearSum(A,5)LinearSum(A,1)LinearSum(A,2)LinearSum(A,3)LinearSum(A,4)callcallcallcall return A[0] = 4return 4 + A[1] = 4 + 3 = 7return 7 + A[2] = 7 + 6 = 13return 13 + A[3] = 13 + 2 = 15call return 15 + A[4] = 15 + 5 = 204 3 6 2 5ARecursion 10Example: Reversing an ArrayAlgorithm ReverseArray(A, i,  j):Input: An array A and nonnegative integer indices i and  jOutput: The reversal of the elements in A starting at index i and ending at  jif i <  j thenSwap A[i] and A[ j]ReverseArray(A, i + 1,  j - 1)returnRecursion 11Defining Arguments for Recursion In creating recursive methods, it is important to define the methods in ways that facilitate recursion. This sometimes requires additional parameters to be passed to the method. For example, we defined the array reversal method as ReverseArray(A, i,  j), not ReverseArray(A).Recursion 12Example: Computing Powers The power function, p(x,n)=xn, can be defined recursively: This leads to a power function that runs in O(n) time (for we make n recursive calls). However, can we do better than this?−⋅==else)1,(0 if1),(nxpxnnxpRecursion 13Recursive Squaring We can derive a more efficient linearly recursive algorithm by using repeated squaring: For example,24=  2(4/2)2 = (24/2)2 = (22)2 = 42 = 1625=  21+(4/2)2 = 2(24/2)2 = 2(22)2 = 2(42) = 3226= 2(6/ 2)2 = (26/2)2 = (23)2 = 82 = 6427= 21+(6/2)2 = 2(26/2)2 = 2(23)2 = 2(82) = 128.>>=−⋅=even is 0 ifodd is 0 if0 if)2/,()2/)1(,(1),(22xxxnxpnxpxnxpRecursion 14Recursive Squaring MethodAlgorithm Power(x, n):Input: A number x and integer n = 0Output: The value xnif n = 0 thenreturn 1if n is odd theny  = Power(x, (n - 1)/ 2)return x · y ·yelsey = Power(x, n/ 2)return y · yRecursion 15AnalysisAlgorithm Power(x, n):Input: A number x and integer n = 0Output: The value xnif n = 0 thenreturn 1if n is odd theny  = Power(x, (n - 1)/ 2)return x · y · yelsey = Power(x, n/ 2)return y · yIt is important that we use a variable twice here rather than calling the method twice.Each time we make a recursive call we halve the value of n; hence, we make log n recursive calls. That is, this method runs in O(log n) time.Recursion 16Tail Recursion Tail recursion occurs when a linearly recursive method makes its recursive call as its last step; as in the array reversal method. Such methods can be easily converted to non-recursive methods (which saves on some resources). Example:Algorithm IterativeReverseArray(A, i, j ):Input: An array A and nonnegative integer indices i and jOutput: The reversal of the elements in A starting at index i and ending at jwhile i <  j doSwap A[i ] and A[ j ]i  = i + 1j  = j - 1returnSee Factorial.javahttp://www.aimanhanna.com/concordia/comp352/Factorial.java.docxRecursion 17Binary Recursion Binary recursion occurs whenever there are two, and exactly two, recursive calls for each non-base case. Applicable, for instance, when attempting to solve two different halves of some problem.  Example: Calculating the summation of an narray elements, can be done by: Recursively summing the elements in the first half; Recursively summing the elements in the second half; Adding the two values. Recursion 18Example: Summing Array ElementsAlgorithm binarySum(A, i, n)Input An array A and integers i and nOutput The sum of the n element of A, starting at index iif n =1 then return A[i]return binarySum(A, i,   n/2   ) + binarySum(A, i +   n/2   ,  n/2    ) Example: Summing n consecutive elements of an array, starting from a given index i, using binary recursion Recursion19Example: Summing Array Elements The following provides an example of abinarySum(0, 8) trace, where each box indicates the starting index and the number of elements to sum.  Analysis: In every half, the call will be made n-1times, resulting in a total of 2n - 1 calls  O(n). However, it should be noted that there is a maximum of 1 + log2 n active calls at any point of time, which improves space utilization as we discuss later.   3, 12, 20, 42, 11, 10, 10, 80, 27, 16, 24, 46, 15, 14, 24, 1Recursion 20Example: Fibonacci Numbers In mathematics, the Fibonacci numbers are the numbers in the following integer sequence: By definition, the first two Fibonacci numbers are 0 and 1, and each subsequent number is the sum of the previous two. Fibonacci numbers can be defined recursively as:F0 =  0F1 =  1Fi =  Fi-1 + Fi-2 for i > 1.Recursion 21Example: Fibonacci Numbers Recursive algorithm (first attempt):Algorithm binaryFib(k):Input: Nonnegative integer kOutput: The kth Fibonacci number Fkif k ≤ 1 thenreturn kelsereturn binaryFib(k - 1) + binaryFib(k - 2)Recursion 22Example: Fibonacci Numbers Analysis: Let nk be the number of recursive calls(notice that this is not the value) by binaryFib(k) n0 = 1 n1 = 1 n2 = n1 + n0 + 1 = 1 + 1 + 1 = 3 n3 = n2 + n1 + 1 = 3 + 1 + 1 = 5 n4 = n3 + n2 + 1 = 5 + 3 + 1 = 9 n5 = n4 + n3 + 1 = 9 + 5 + 1 = 15 n6 = n5 + n4 + 1 = 15 + 9 + 1 = 25 n7 = n6 + n5 + 1 = 25 + 15 + 1 = 41 n8 = n7 + n6 + 1 = 41 + 25 + 1 = 67. Note that nk at least doubles every other time. In fact, nk > 2k/2. It is exponential!Recursion 23Example: Fibonacci Numbers The main problem with binaryFib(k) approach is that the computation of Fibonacci numbers is really a linearly recursive problem, in spite of its look where Fkdepends on Fk-1 and Fk-2. The problem is hence not a good candidate for binary recursion.  We should use linear recursion instead. Recursion 24A Better Fibonacci Algorithm  Use linear recursion insteadAlgorithm linearFibonacci(k):Input: A nonnegative integer kOutput: Pair of Fibonacci numbers (Fk , Fk-1)if k = 1 thenreturn (k, 0)else(i,  j)  =  linearFibonacci(k - 1)return (i +j, i)// notice that the values are retuned (however, not both are displayed)  linearFibonacci makes k-1 recursive calls, so total calls is k. See LinearFib.java & BinaryFibStack.javahttp://www.aimanhanna.com/concordia/comp352/LinearFib.java.dochttp://www.aimanhanna.com/concordia/comp352/BinaryFibStack.java.docRecursion 25A Better Fibonacci Algorithm For instance (note: Fib is short for linearFibonacci), Fib(2)  (i+j, i) is (1,1)  Will be displaying 1  Fib(3)  (i+j, i) is (2,1)  Will be displaying 2  Fib(4)  (i+j, i) is (3,2)  Will be displaying 3  Fib(5)  (i+j, i) is (5,3)  Will be displaying 5  Fib(6)  (i+j, i) is (8,5)  Will be displaying 8  Fib(7)  (i+j, i) is (13,8)  Will be displaying 13  Fib(8)  (i+j, i) is (21,13)  Will be displaying 21  Fib(9)  (i+j, i) is (34,21)  Will be displaying 34  : Fib(12)  (i+j, i) is (144,89)  Will be displaying 144 Binary Recursion Another Example The English Ruler:  Print the ticks and numbers like an English rulerRecursion 26Example: The English RulerRecursion 27drawTicks(length)Input: length of a ‘tick’Output: ruler with tick of the given length in the middle and smaller rulers on either sidedrawTicks(length) if( length > 0 ) thendrawTicks( length − 1 )draw tick of the given lengthdrawTicks( length − 1 )Slide by Matt Stallmann included with permission.Recursive Drawing Method  The drawing method is based on the following recursive definition An interval with a central tick length L >1 consists of: An interval with a central tick length L−1 An single tick of length L An interval with a central tick length L−1Recursion 28drawTicks (3) OutputdrawTicks (0)(previous pattern repeats )drawOneTick (1)drawTicks (1)drawTicks (2)drawOneTick (2)drawTicks (2)drawTicks (1)drawTicks (0)drawTicks (0)drawTicks (0)drawOneTick (1)drawOneTick (3)Java Implementation (1)// draw ruler public static void  drawRuler(int nInches,  int majorLength)  {drawOneTick(majorLength,  0); // draw tick 0 and its labelfor  (int i =  1; i <=  nInches;  i++) {drawTicks(majorLength- 1); // draw ticks for this inchdrawOneTick(majorLength,  i); // draw tick i and its label}}// draw ticks of given lengthpublic static void  drawTicks(int tickLength)  { if  (tickLength >  0)  { // stop when length drops to 0drawTicks(tickLength- 1); // recursively draw left ticksdrawOneTick(tickLength); // draw center tickdrawTicks(tickLength- 1); // recursively draw right ticks}}Recursion 29Note the two recursive callsJava Implementation (2)// draw one tick; // passing last parameter as -1 will draw ticks without a labelpublic static void  drawOneTick(int tickLength,  int tickLabel)  {for  (int i =  0; i <  tickLength;  i++)System.out.print("-");if  (tickLabel >=  0)  System.out.print(" "  +  tickLabel);System.out.print("\n");}Recursion 30Recursion 31Multiple Recursion Multiple recursion:  Makes potentially many recursive calls Not just one or two Motivating example:  Coping folders (directories)   Finding enumerations of sequence  {a,b,c} : abc, acb, bac, bca, cab, cbaRecursion 32Example of Multiple RecursionAlgorithm CopyFolder(folder):Input: A directory folder, which possibly includes files and subfoldersOutput:  A copy of the given folder with all its files and subfoldersfor all files in folder docopy file for all subfolder in folder docopyfolder(subfolder)  // this line is where recursion happensRecursion 33Example of Multiple RecursionAlgorithm PuzzleSolve(k,S,U):Input: Integer k, sequence S, and set U (universe of elements to test)Output:  Enumeration of all k-length extensions to S using elements in U without repetitionsfor all e  in U doRemove e from U {e is now being used}Add e to the end of Sif k = 1 thenTest whether S is a configuration that solves the puzzleif S solves the puzzle thenreturn “Solution found: ” SelsePuzzleSolve(k - 1, S,U)Add e back to U {e is now unused}Remove e from the end of SExample of Multiple Recursion34Recursioncbb + ba = abc a,b,c stand for 7,8,9; not necessarily in that order[] {a,b,c}[a] {b,c}a=7[b] {a,c}b=7[c] {a,b}c=7[ab] {c}a=7,b=8c=9[ac] {b}a=7,c=8b=9[ba] {c}b=7,a=8c=9[bc] {a}b=7,c=8a=9[ca] {b}c=7,a=8b=9[cb] {a}c=7,b=8a=9might be able tostop soonerSlide by Matt Stallmann included with permission.799 + 98 = 997Recursion35Visualizing PuzzleSolvePuzzleSolve (3,(),{a,b,c})Initial callPuzzleSolve (2,c,{a,b})PuzzleSolve (2,b,{a,c})PuzzleSolve (2,a,{b,c})PuzzleSolve (1,ab,{c})PuzzleSolve (1,ac,{b}) PuzzleSolve (1,cb,{a})PuzzleSolve (1,ca,{b})PuzzleSolve (1,bc,{a})PuzzleSolve (1,ba,{c})abcacbbacbcacabcba Notice that the number of concurrently active calls can still be limited with multiple recursion.  For instance, the number of active calls of CopyFolderdepends on how many nested subfolders may exist at a time and not on the total number of subfolders in the directory.  	Recursion	The Recursion Pattern	Content of a Recursive Method	Visualizing Recursion	Recursion & The Stack	Recursion & The Stack	Recursion & The Stack	Linear Recursion	Example of Linear Recursion	Example: Reversing an Array	Defining Arguments for Recursion	Example: Computing Powers	Recursive Squaring	Recursive Squaring Method	Analysis	Tail Recursion	Binary Recursion	Example: Summing Array Elements	Example: Summing Array Elements	Example: Fibonacci Numbers	Example: Fibonacci Numbers	Example: Fibonacci Numbers	Example: Fibonacci Numbers	A Better Fibonacci Algorithm 	A Better Fibonacci Algorithm 	Binary Recursion �Another Example	Example: The English Ruler	Recursive Drawing Method 	Java Implementation (1)	Java Implementation (2)	Multiple Recursion	Example of Multiple Recursion	Example of Multiple Recursion	Example of Multiple Recursion	Visualizing PuzzleSolve
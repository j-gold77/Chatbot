Analysis of AlgorithmsQuick-SortDr. Aiman HannaDepartment of Computer Science & Software Engineering Concordia University, Montreal, CanadaThese slides has been extracted, modified and updated from original slides of :Data Structures and Algorithms in Java, 5th edition. John Wiley& Sons, 2010. ISBN 978-0-470-38326-1.Data Structures and the Java Collections Framework by William J. Collins, 3rdedition, ISBN 978-0-470-48267-4. Both books are published by Wiley.Copyright © 2010-2011 WileyCopyright © 2010 Michael  T. Goodrich, Roberto TamassiaCopyright © 2011 William J. CollinsCopyright © 2011-2021 Aiman Hanna All rights reserved Coverage Quick-Sort27  4  9  6 2  → 2  4  6 7  94 2  → 2  4 7 9  → 7 92 → 2 9 → 9Quick SortQuick Sort 3Quick-Sort Quick-sort is a randomized sorting algorithm based on the divide-and-conquer paradigm: Divide: pick a random element x (called pivot) and partition S into  L elements less than x E elements equal x G elements greater than x Recur: sort L and G Conquer: join L, E and GxxL GExQuick Sort 4Partition We partition an input sequence as follows: We remove, in turn, each element y from S and  We insert y into L, E or G,depending on the result of the comparison with the pivot x Each insertion and removal is at the beginning or at the end of a sequence, and hence takes O(1) time Thus, the partition step of quick-sort takes O(n) timeAlgorithm partition(S, p)Input sequence S, position p of pivot Output subsequences L, E, G of the elements of S less than, equal to,or greater than the pivot, resp.L, E, G ← empty sequencesx ← S.remove(p)while ¬S.isEmpty()y ← S.remove(S.first())if y < xL.addLast(y)else if y = xE.addLast(y)else { y > x }G.addLast(y)return L, E, GQuick-Sort Tree An execution of quick-sort is depicted by a binary tree Each node represents a recursive call of quick-sort and stores Unsorted sequence before the execution and its pivot Sorted sequence at the end of the execution The root is the initial call  The leaves are calls on subsequences of size 0 or 15Quick SortQuick Sort 6Quick-Sort Tree Example:85  24  63  45  17  31  96     5024  45  17   31 85  63     96Divide & Recur4524    172485   6385Quick Sort 7Quick-Sort Tree Example (Continues…):17  24  31  45     50 63  85  9617  24 31 45 63  85     96Conquer4517   242463 8585Quick Sort 8Execution Example Pivot selection7  2  9  4  → 2  4  7  92 → 27  2  9  4 3  7  6 1 → 1  2  3  4  6  7  8  93  8  6  1  → 1  3  8  63 → 3 8 → 89  4  → 4  99 → 9 4 → 4Quick Sort 9Execution Example (cont.) Partition, recursive call, pivot selection2 4  3  1 → 2  4  7  99  4  → 4  99 → 9 4 → 47  2  9  4  3  7  6 1 → 1  2  3  4  6  7  8  93  8  6  1  → 1  3  8  63 → 3 8 → 82 → 2Quick Sort 10Execution Example (cont.) Partition, recursive call, base case2 4  3  1 →→ 2  4  7  1 → 1 9  4  → 4  99 → 9 4 → 47  2  9  4 3  7  6 1 → → 1  2  3  4  6  7  8  93  8  6  1  → 1  3  8  63 → 3 8 → 8Quick Sort 11Execution Example (cont.) Recursive call, …, base case, join3  8  6  1  → 1  3  8  63 → 3 8 → 87  2  9  4 3  7  6 1 → 1  2  3  4  6  7  8  92 4  3  1 → 1  2 3  41 → 1 4  3 → 3 49 → 9 4 → 4Quick Sort 12Execution Example (cont.) Recursive call, pivot selection7  9  7 1  → 1  3  8  68 → 87  2  9  4 3  7  6 1 → 1  2  3  4  6  7  8  92 4  3  1 → 1  2 3  41 → 1 4  3 → 3 49 → 9 4 → 49 → 9Quick Sort 13Execution Example (cont.) Partition, …, recursive call, base case7  9  7 1  → 1  3  8  68 → 87  2  9  4 3  7  6 1 → 1  2  3  4  6  7  8  92 4  3  1 → 1  2 3  41 → 1 4  3 → 3 49 → 9 4 → 49 → 9Quick Sort 14Execution Example (cont.) Join, join7 9  7 → 17 7 98 → 87  2  9  4  3  7  6 1  → 1  2  3  4  6 7  7  92 4  3  1 → 1  2 3  41 → 1 4  3 → 3 49 → 9 4 → 49 → 9Quick Sort 15Worst-case Running Time The worst case for quick-sort occurs when the pivot is the unique minimum or maximum element One of L and G has size n − 1 and the other has size 0 The amount or work done at any depth proportional to the number of nodes at that depth. Hence, the running time in that case is proportional to the sumn + (n − 1) + … + 2 + 1 Thus, the worst-case running time of quick-sort is O(n2)depth time0 n1 n − 1… …n − 1 1Quick Sort 16Expected Running Time Consider a recursive call of quick-sort on a sequence of size s Good call: the sizes of L and G are each less than 3s/4 Bad call: one of L and G has size greater than 3s/4 A call is good with probability 1/2 1/2 of the possible pivots cause good calls:7  9  7 1  → 17  2  9  4 3  7  6 1 92  4  3  1 7 9 4 3 7 617  2 9  4 3  7  6  1Good call Bad call1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16Good pivotsBad pivots Bad pivotsQuick Sort 17Expected Running Time, Part 2 Probabilistic Fact: The expected number of coin tosses required in order to get k heads is 2k For a node of depth i, we expect i/2 ancestors are good calls (that is ½ the calls above) The size of the input sequence for the current call is at most (3/4)i/2ns(r)s(a) s(b)s(c) s(d) s(f)s(e)time per levelexpected heightO(log n)O(n)O(n)O(n)total expected time: O(n log n)Therefore,  When the expected input size finally reaches one? It does at depth i = 2log4/3n i.e. n=100, (3/4)log4/3(100) 100 = 1 The expected height of the quick-sort tree is O(log n)The amount or work done at the nodes of the same depth is O(n)Thus, the expected running time of quick-sort is O(n log n)Quick Sort 18In-Place Quick-Sort Quick-sort can be implemented to run in-place In the partition step, we use replace operations to rearrange the elements of the input sequence such that the elements less than the pivot have rank less than h the elements equal to the pivot have rank between h and k the elements greater than the pivot have rank greater than k The recursive calls consider elements with rank less than h elements with rank greater than kAlgorithm inPlaceQuickSort(S, l, r)Input sequence S, ranks l and rOutput sequence S with theelements of rank between l and rrearranged in increasing orderif l ≥ rreturni ← a random integer between l and rx ← S.elemAtRank(i)(h, k) ← inPlacePartition(x)inPlaceQuickSort(S, l, h − 1)inPlaceQuickSort(S, k + 1, r)Quick Sort 19In-Place Partitioning Perform the partition using two indices to split S into L and E U G (a similar method can split E U G into E and G). Repeat until j and k cross: Scan j to the right until finding an element > x. Scan k to the left until finding an element < x. Swap elements at indices j and k Click here for a good illustrative example.3  2  5  1  0  7  3  5  9  2  7  9  8  9  7  6 9j k(pivot = 6)3  2  5  1  0  7  3  5  9  2  7  9  8  9  7  6 9j khttp://www.csanimated.com/animation.php?t=QuicksortQuick Sort 20Summary of Sorting AlgorithmsAlgorithm Time Notesselection-sort O(n2)  in-place slow (good for small inputs)insertion-sort O(n2)  in-place slow (good for small inputs)quick-sort O(n log n)expected in-place, randomized fastest (good for large inputs) Quick-sort is often faster in practice than other O(n log n) algorithms.heap-sort O(n log n)  in-place fast (good for large inputs)merge-sort O(n log n)  sequential data access fast  (good for huge inputs)	Quick-Sort	Slide Number 2	Quick-Sort	Partition	Quick-Sort Tree	Quick-Sort Tree	Quick-Sort Tree	Execution Example	Execution Example (cont.)	Execution Example (cont.)	Execution Example (cont.)	Execution Example (cont.)	Execution Example (cont.)	Execution Example (cont.)	Worst-case Running Time	Expected Running Time	Expected Running Time, Part 2	In-Place Quick-Sort	In-Place Partitioning	Summary of Sorting Algorithms
COMP 352 â€“ WINTER 2020COMP 352Tutorial Session 101OUTLINEï‚¢ Sorting propertiesï‚¢ Sorting algorithmsï‚— Quicksortï‚— Mergesortï‚— Bucket sortï‚— Radix sortï‚¢ Exerciseï‚¢ For live demo please check https://www.toptal.com/developers/sorting-algorithms 2SORT ALGORITHM PROPERTIESIN-PLACE SORTING AND NOT-IN-PLACE SORTINGï‚¢ Sorting algorithms may require extra space for comparison and temporary storage of data elementsï‚¢ A sorting algorithm is in-place ifï‚— it uses no auxiliary data structures (however, O(1) auxiliary variables are allowed)ï‚— it updates the input sequence only by means of operations replaceElement and swapElementsï‚¢Bubble sort is an example of in-place sorting and Merge-sort is an example of not-in-place sorting.3SORT ALGORITHM PROPERTIESSTABLE SORT4ï‚¢ If a sorting algorithm, after sorting the contents, does not change the sequence of appearance of duplicates relative to the original ordering, it is called stable sorting.ï‚¢ If a sorting algorithm, after sorting the contents, changes the sequence of appearance of duplicates relative to the original ordering, it is called unstable sorting.ïµ Stability of an algorithm matters when we wish to maintain the sequence of original elements, like in a tuple for example.QUICKSORT: OUTLINERecursive method:Input: array, firstindex, lastindex1. Check the stopping case: firstindex<lastindex1. Find the splitpoint : partitionïƒ Most important point NEXT SLIDE!!!!2. Recursion on left part3. Recursion on Right part5THE QUICKSORT :  ALGORITHMPartition: return the pivot position1) Choose a pivot2) Set a left pointer and right pointer3) Compare the left pointer element (lelement) with the pivot and the right pointer element (relement) with the pivot.4) Check if lelement<pivot and relement>pivot:a. If yes, increment the left pointer and decrement the right pointerb. If not, swap the lelement and relement5) When left >= right, swap the pivot with either left or right pointer.6PARTITION ALGORITHM: EXAMPLE1. Choosing the pivot:2. Moving through the array to find the last position of the pivot: the partition7PARTITION: CONTâ€™D8PARTITION: CONTâ€™D9PARTITION: END10ANALYSIS OF COMPLEXITY1. Worst case: O(N2)â€¢ When the array is sorted and one choose as pivot the smallest/largest element. Then one partition is empty the other has N-1 2. Best case: O(NlogN)â€¢ When the pivot is the median of the array an the partitions have the same sizeâ€¢ Then we have log(N) partitions on which N comparisons are applied.3. Average case: O(NlogN)11MERGE SORT12Idea: Mergesort is a divide and conquer algorithm. The fundamental operations in this algorithm are dividing the array into two sub-lists with equal length and merging these two sorted lists.RUNNING TIME OF MERGE-SORTï‚¢ At each level in the binary tree created for Merge-Sort O(n) time is spent (splitting and recombining sequences S1, S2)ï‚¢ The height of the tree is O(log n) by splitting the sequences in half each timeï‚¢ Therefore, the time complexity is O(N log N)131414BUCKET-SORTConsider a sequence S of n entries whose keys are integers in the range [0, Nâˆ’1], for some integer N â‰¥ 2, and suppose that S should be sorted according to the keys of the entries. The crucial point is that, because of the restrictive assumption about the format of the elements, we can avoid using comparisonsExample:For simplicity, consider the key in the range 0 to 9. Input data: (1, ğ‘£ğ‘£1), (4, ğ‘£ğ‘£2), (1, ğ‘£ğ‘£3), (2, ğ‘£ğ‘£4), (7, ğ‘£ğ‘£5), (5, ğ‘£ğ‘£6), (2, ğ‘£ğ‘£7)15RADIX-SORTWe want to sort entries with keys that are pairs (k, l), where k and l are integers in the range [0, Nâˆ’1], for some integer N â‰¥ 2. In a context such as this, it is natural to define an ordering on these keys using the lexicographical (dictionary) convention, where (ğ’Œğ’ŒğŸğŸ, ğ’ğ’ğŸğŸ)<(ğ’Œğ’ŒğŸğŸ, ğ’ğ’ğŸğŸ) if ğ’Œğ’ŒğŸğŸ < ğ’Œğ’ŒğŸğŸ or if ğ’Œğ’ŒğŸğŸ = ğ’Œğ’ŒğŸğŸ and ğ’ğ’ğŸğŸ < ğ’ğ’ğŸğŸ .16PROBLEM SOLVING -PROBLEM 1Given an array of size n, find all elements in array that appear more than n/k times. For example, if the input arrays is {3, 1, 2, 2, 1, 2, 3, 3} and k is 4, then the output should be [2, 3]. Note that size of array is 8 (or n = 8), so we need to find all elements that appear more than 2 (or 8/4) times. There are two elements that appear more than two times, 2 and 3.PROBLEM SOLVING -PROBLEM 2You are given a set of n real numbers and another real number x. Describe an O(nlogn) time algorithm that determines whether or not there exists 2 elements in S whose sum is exactly x.1718Problem Solving -Problem 3You are given an array of n+2 elements. All elements of the array are in range 1 to n. And all elements occur once except two numbers which occur twice. Find the two repeating numbers.For example, array = {4, 2, 4, 5, 2, 3, 1} and n = 5The above array has n + 2 = 7 elements with all elements occurring once except 2 and 4 which occur twice. So the output should be 4 2.PROBLEM SOLVING -PROBLEM 4:Suppose we are given an n-element sequence S such that each element in S represents a different vote for president, where each vote is given as an integer representing a particular candidate. Design an O(nlogn) time algorithm to see who wins the election S represents, assuming the candidate with the most votes wins (even if there are O(n) candidates).19	COMP 352	outline	Sort Algorithm Propertiesï¿½In-place Sorting and Not-in-place Sorting	Sort Algorithm Propertiesï¿½Stable Sort	Quicksort: outline	The Quicksort :  algorithm	Partition algorithm: example	Partition: contâ€™d	Partition: contâ€™d	Partition: end	Analysis of complexity	Merge sort	Running Time of Merge-Sort	Slide Number 14	Slide Number 15	Slide Number 16	Problem Solving -ï¿½Problem 2	Slide Number 18	Problem Solving -ï¿½Problem 4: